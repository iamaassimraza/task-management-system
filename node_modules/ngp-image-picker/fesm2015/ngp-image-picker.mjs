import { __awaiter } from 'tslib';
import * as i0 from '@angular/core';
import { EventEmitter, Component, Input, Output, HostListener, ViewEncapsulation, ChangeDetectionStrategy, ViewChild, NgModule } from '@angular/core';
import * as i1 from '@angular/common';
import { CommonModule } from '@angular/common';
import * as i2 from '@angular/forms';
import { FormsModule, ReactiveFormsModule } from '@angular/forms';

const MAX_BUFFER_UNDO_MEMORY = 25;
let rotate = 1;
const convertImageUsingCanvas = (datas, changeHeight = false, state, options) => {
    return new Promise((resolve, _) => __awaiter(void 0, void 0, void 0, function* () {
        let img = document.createElement('img');
        img.src = datas + '';
        img.crossOrigin = 'Anonymous';
        let quality = state.quality / 100;
        let maintainRatio = state.maintainAspectRatio;
        img.onload = () => {
            var canvas = document.createElement('canvas');
            let ctx = canvas.getContext('2d');
            if (!ctx)
                return;
            let ratio = img.width / img.height;
            let width = state.maxWidth;
            let height = state.maxHeight;
            if (options === null || options === void 0 ? void 0 : options.getDimFromImage) {
                width = img.width;
                height = img.height;
            }
            if (maintainRatio) {
                canvas.width = width;
                canvas.height = width / ratio;
                if (changeHeight) {
                    canvas.width = height * ratio;
                    canvas.height = height;
                }
            }
            else {
                canvas.width = width;
                canvas.height = height;
            }
            if (state.basicFilters) {
                ctx.filter = processFilter(state.basicFilters);
            }
            // if (options?.rotate) {
            //   canvas.width = height;
            //   canvas.height = width;
            //   if (options?.rotate === 90) {
            //     ctx.rotate((90 * Math.PI) / 180);
            //     ctx.translate(0, -canvas.width);
            //   } else {
            //     ctx.rotate((-90 * Math.PI) / 180);
            //     ctx.translate(-canvas.height, 0);
            //   }
            //   ctx.drawImage(img, 0, 0);
            // } else {
            // }
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            let type = state.format;
            var dataURI = canvas.toDataURL(`image/${type}`, quality);
            resolve({
                dataUri: dataURI,
                width: canvas.width,
                height: canvas.height,
            });
        };
    })).then((data) => {
        state.maxHeight = data.height;
        state.maxWidth = data.width;
        saveState(state, data.dataUri);
        return data.dataUri;
    });
    function processFilter(data) {
        return Object.keys(data)
            .map((key) => {
            if (['blur'].includes(key)) {
                return `${key}(${data[key]}px)`;
            }
            else {
                return `${key}(${data[key]})`;
            }
        })
            .join('');
    }
};
const dragElement = (elemnt) => {
    if (!elemnt)
        return;
    let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
    if (document.getElementById(elemnt.id + '-header')) {
        /* if present, the header is where you move the DIV from:*/
        let elementRef = document.getElementById((elemnt === null || elemnt === void 0 ? void 0 : elemnt.id) + '-header');
        if (!elementRef)
            return;
        elementRef.onmousedown = dragPressOn;
        elementRef.ontouchstart = dragPressOn;
    }
    else {
        /* otherwise, move the DIV from anywhere inside the DIV:*/
        elemnt.ontouchstart = dragPressOn;
        elemnt.onmousedown = dragPressOn;
    }
    function dragPressOn(e) {
        let popup = document.querySelector('#popup');
        popup.style.overflowY = 'hidden';
        e = e || window.event;
        pos3 = e.clientX;
        pos4 = e.clientY;
        document.ontouchend = closeDragElement;
        document.onmouseup = closeDragElement;
        document.ontouchmove = elementDragTouch;
        document.onmousemove = elementDragMouse;
    }
    function elementDragMouse(e) {
        let holderImage = document.getElementById('image-full');
        e = e || window.event;
        pos1 = pos3 - e.clientX;
        pos3 = e.clientX;
        pos2 = pos4 - e.clientY;
        pos4 = e.clientY;
        let newTop = elemnt.offsetTop - pos2;
        let newLeft = elemnt.offsetLeft - pos1;
        let rectHolder = holderImage === null || holderImage === void 0 ? void 0 : holderImage.getBoundingClientRect();
        let rectElemnt = elemnt.getBoundingClientRect();
        // console.log('====================================');
        // console.log(rectElemnt,rectHolder);
        // console.log('====================================');
        newTop = Math.max(newTop, rectHolder === null || rectHolder === void 0 ? void 0 : rectHolder.top);
        newTop = Math.min(newTop, (rectHolder === null || rectHolder === void 0 ? void 0 : rectHolder.bottom) - rectElemnt.height);
        newLeft = Math.max(newLeft, rectHolder === null || rectHolder === void 0 ? void 0 : rectHolder.left);
        newLeft = Math.min(newLeft, (rectHolder === null || rectHolder === void 0 ? void 0 : rectHolder.right) - rectElemnt.width);
        elemnt.style.top = newTop + 'px';
        elemnt.style.left = newLeft + 'px';
    }
    function elementDragTouch(e) {
        var _a, _b, _c, _d, _e, _f;
        let holderImage = document.getElementById('image-full');
        e = e || window.event;
        if ((_a = e === null || e === void 0 ? void 0 : e.changedTouches) === null || _a === void 0 ? void 0 : _a.length) {
            pos1 = pos3 - ((_b = e.changedTouches[0]) === null || _b === void 0 ? void 0 : _b.clientX);
            pos3 = (_c = e.changedTouches[0]) === null || _c === void 0 ? void 0 : _c.clientX;
        }
        if ((_d = e === null || e === void 0 ? void 0 : e.changedTouches) === null || _d === void 0 ? void 0 : _d.length) {
            pos2 = pos4 - ((_e = e.changedTouches[0]) === null || _e === void 0 ? void 0 : _e.clientY);
            pos4 = (_f = e.changedTouches[0]) === null || _f === void 0 ? void 0 : _f.clientY;
        }
        let newTop = elemnt.offsetTop - pos2;
        let newLeft = elemnt.offsetLeft - pos1;
        let rectHolder = holderImage === null || holderImage === void 0 ? void 0 : holderImage.getBoundingClientRect();
        let rectElemnt = elemnt.getBoundingClientRect();
        // console.log('====================================');
        // console.log(rectElemnt,rectHolder);
        // console.log('====================================');
        newTop = Math.max(newTop, rectHolder === null || rectHolder === void 0 ? void 0 : rectHolder.top);
        newTop = Math.min(newTop, (rectHolder === null || rectHolder === void 0 ? void 0 : rectHolder.bottom) - rectElemnt.height);
        newLeft = Math.max(newLeft, rectHolder === null || rectHolder === void 0 ? void 0 : rectHolder.left);
        newLeft = Math.min(newLeft, (rectHolder === null || rectHolder === void 0 ? void 0 : rectHolder.right) - rectElemnt.width);
        elemnt.style.top = newTop + 'px';
        elemnt.style.left = newLeft + 'px';
    }
    function closeDragElement() {
        /* stop moving when mouse button is released:*/
        let popup = document.querySelector('#popup');
        popup.style.overflowY = 'auto';
        document.onmouseup = null;
        document.onmousemove = null;
        document.ontouchend = null;
        document.ontouchmove = null;
    }
};
const saveState = (state, lastImage) => {
    if (state.arrayCopiedImages.length <= MAX_BUFFER_UNDO_MEMORY) {
        state.arrayCopiedImages.push({
            lastImage: lastImage,
            width: state.maxWidth,
            height: state.maxHeight,
            quality: state.quality,
            format: state.format,
            originImageSrc: state.originImageSrc,
            basicFilters: state.basicFilters,
        });
    }
    else {
        state.arrayCopiedImages[state.arrayCopiedImages.length - 1] = {
            lastImage: lastImage,
            width: state.maxWidth,
            height: state.maxHeight,
            quality: state.quality,
            format: state.format,
            originImageSrc: state.originImageSrc,
            basicFilters: state.basicFilters,
        };
    }
};

var Remove$3 = "Quitar";
var Quality$3 = "Calidad";
var Format$3 = "Formato";
var Crop$3 = "Recortar";
var Save$3 = "Guardar";
var Contrast$3 = "Contraste";
var Blur$3 = "Blur";
var Brightness$3 = "Brillo";
var Grayscale$3 = "Scala de gris";
var Saturate$2 = "Saturación";
var Sepia$3 = "Sepia";
var Rotate$1 = "Rotar";
var Undo$3 = "Deshacer";
var labelEs = {
    "Upload a image": "Suba una imagen",
    "You must edit the image in order to resize it": "Debe editar la imagen para disminuir su tamaño",
    "too large": "muy grande",
    "Open the editor panel": "Abra el panel de edición",
    "Download the image": "Descarge la imagen",
    "Control Panel": "Panel de control",
    Remove: Remove$3,
    Quality: Quality$3,
    "Max dimensions": "Dimensiones",
    "aspect-ratio": "relación-aspecto",
    "max-width(px)": "max. ancho",
    "max-height(px)": "max. alto",
    Format: Format$3,
    Crop: Crop$3,
    "width(px)": "ancho(px)",
    "height(px)": "altura(px)",
    Save: Save$3,
    Contrast: Contrast$3,
    Blur: Blur$3,
    Brightness: Brightness$3,
    Grayscale: Grayscale$3,
    Saturate: Saturate$2,
    Sepia: Sepia$3,
    Rotate: Rotate$1,
    Undo: Undo$3
};

var Quality$2 = "Quality";
var Format$2 = "Format";
var Crop$2 = "Crop";
var Remove$2 = "Remove";
var Save$2 = "Save";
var Contrast$2 = "Contrast";
var Blur$2 = "Blur";
var Brightness$2 = "Brightness";
var Grayscale$2 = "Grayscale";
var Saturate$1 = "Saturate";
var Sepia$2 = "Sepia";
var Rotate = "Rotate";
var Undo$2 = "Undo";
var labelEn = {
    "Upload a image": "Upload a image",
    "You must edit the image in order to resize it": "You must edit the image in order to resize it",
    "too large": "too large",
    "Open the editor panel": "Open the editor panel",
    "Download the image": "Download the image",
    "Control Panel": "Control Panel",
    Quality: Quality$2,
    "Max dimensions": "Max dimensions",
    "aspect-ratio": "aspect-ratio",
    "max-width(px)": "max-width(px)",
    "max-height(px)": "max-height(px)",
    Format: Format$2,
    Crop: Crop$2,
    "width(px)": "width(px)",
    "height(px)": "height(px)",
    Remove: Remove$2,
    Save: Save$2,
    Contrast: Contrast$2,
    Blur: Blur$2,
    Brightness: Brightness$2,
    Grayscale: Grayscale$2,
    Saturate: Saturate$1,
    Sepia: Sepia$2,
    Rotate: Rotate,
    Undo: Undo$2
};

var Remove$1 = "Supprimer";
var Quality$1 = "Qualité";
var Format$1 = "Format";
var Crop$1 = "Recadrer";
var Save$1 = "Sauvez";
var Contrast$1 = "Contraste";
var Blur$1 = "Blur";
var Brightness$1 = "Luminosité";
var Grayscale$1 = "Grayscale";
var Saturate = "Saturer";
var Sepia$1 = "Seiche";
var Undo$1 = "Annuler";
var labelFr = {
    "Upload a image": "Charger une image",
    "You must edit the image in order to resize it": "Vous devez éditer l'image pour changer sa taille",
    "too large": "Trop grande",
    "Open the editor panel": "Ouvrir le panneau d'édition",
    "Download the image": "Télécharger l'image",
    "Control Panel": "Panneau de commande",
    Remove: Remove$1,
    Quality: Quality$1,
    "Max dimensions": "Dimensions maximales",
    "aspect-ratio": "rapport de forme",
    "max-width(px)": "largeur max.",
    "max-height(px)": "hauteur max",
    Format: Format$1,
    Crop: Crop$1,
    "width(px)": "largeur(px)",
    "height(px)": "hauteur(px)",
    Save: Save$1,
    Contrast: Contrast$1,
    Blur: Blur$1,
    Brightness: Brightness$1,
    Grayscale: Grayscale$1,
    Saturate: Saturate,
    Sepia: Sepia$1,
    Undo: Undo$1
};

var Quality = "Qualität";
var Format = "Format";
var Crop = "Zuschneiden";
var Remove = "Entfernen";
var Save = "Speichern";
var Contrast = "Kontrast";
var Blur = "Blur";
var Brightness = "Helligkeit";
var Grayscale = "Graustufen";
var Saturer = "Sättigen";
var Sepia = "Tintenfisch";
var Undo = "Undo";
var labelDe = {
    "Upload a image": "Bild hochladen",
    "You must edit the image in order to resize it": "Sie müssen das Bild bearbeiten, um seine Größe zu ändern",
    "too large": "zu groß",
    "Open the editor panel": "Editor-Fenster öffnen",
    "Download the image": "Bild herunterladen",
    "Control Panel": "Bedienfeld",
    Quality: Quality,
    "Max dimensions": "Maximale Größe",
    "aspect-ratio": "Seitenverhältnis",
    "max-width(px)": "Max. Breite(px)",
    "max-height(px)": "Max. Höhe(px)",
    Format: Format,
    Crop: Crop,
    "width(px)": "Breite(px)",
    "height(px)": "Höhe(px)",
    Remove: Remove,
    Save: Save,
    Contrast: Contrast,
    Blur: Blur,
    Brightness: Brightness,
    Grayscale: Grayscale,
    Saturer: Saturer,
    Sepia: Sepia,
    Undo: Undo
};

class TabsComponent {
    constructor() {
        this.labels = [];
        this.indexActivated = 0;
        this.color = '';
        this.indexActivatedChange = new EventEmitter();
    }
    set _labels(value) {
        if (value === null || value === void 0 ? void 0 : value.length) {
            this.labels = value.map((el) => ({ active: false, label: el }));
            this.labels[this.indexActivated].active = true;
        }
    }
    set _indexActivated(index) {
        this.indexActivated = index || 0;
    }
    onActivateTab(itemIndex) {
        this.labels = this.labels.map((el, index) => {
            el.active = itemIndex === index ? true : false;
            return el;
        });
        this.indexActivated = itemIndex;
        this.indexActivatedChange.next(itemIndex);
    }
    ngOnInit() { }
}
TabsComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: TabsComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
TabsComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: TabsComponent, selector: "lib-tabs", inputs: { color: "color", _labels: "_labels", _indexActivated: "_indexActivated" }, outputs: { indexActivatedChange: "indexActivatedChange" }, ngImport: i0, template: "<div class=\"header\">\n  <div\n    (click)=\"onActivateTab(index)\"\n    *ngFor=\"let tab of this.labels; let index = index\"\n    class=\"itemlabel bottomLine\"\n    [ngStyle]=\"{ color: tab.active ? color : 'inherit', opacity: tab.active ? 1 : 0.7, fontWeight: tab.active ? 500 : 'inherit' }\"\n  >\n    {{ tab.label }}\n    <div *ngIf=\"tab.active\" [style.backgroundColor]=\"this.color\"></div>\n  </div>\n</div>\n\n<div class=\"body\">\n  <ng-content></ng-content>\n</div>\n", styles: [".header{display:flex;padding:0 8px;box-sizing:border-box;justify-content:flex-start;align-items:center;overflow-x:auto;font-size:16px;border-bottom:1px solid #323232}.header .itemlabel{display:flex;justify-content:center;align-items:center;padding:.5rem .65rem;min-height:48px;box-sizing:border-box;white-space:nowrap;text-transform:capitalize;cursor:pointer;opacity:.7}.header .itemlabel.bottomLine{position:relative;opacity:1}.header .itemlabel.bottomLine div{position:absolute;width:100%;bottom:0;height:3px}.body{padding:16px 8px}\n"], dependencies: [{ kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: TabsComponent, decorators: [{
            type: Component,
            args: [{ selector: 'lib-tabs', template: "<div class=\"header\">\n  <div\n    (click)=\"onActivateTab(index)\"\n    *ngFor=\"let tab of this.labels; let index = index\"\n    class=\"itemlabel bottomLine\"\n    [ngStyle]=\"{ color: tab.active ? color : 'inherit', opacity: tab.active ? 1 : 0.7, fontWeight: tab.active ? 500 : 'inherit' }\"\n  >\n    {{ tab.label }}\n    <div *ngIf=\"tab.active\" [style.backgroundColor]=\"this.color\"></div>\n  </div>\n</div>\n\n<div class=\"body\">\n  <ng-content></ng-content>\n</div>\n", styles: [".header{display:flex;padding:0 8px;box-sizing:border-box;justify-content:flex-start;align-items:center;overflow-x:auto;font-size:16px;border-bottom:1px solid #323232}.header .itemlabel{display:flex;justify-content:center;align-items:center;padding:.5rem .65rem;min-height:48px;box-sizing:border-box;white-space:nowrap;text-transform:capitalize;cursor:pointer;opacity:.7}.header .itemlabel.bottomLine{position:relative;opacity:1}.header .itemlabel.bottomLine div{position:absolute;width:100%;bottom:0;height:3px}.body{padding:16px 8px}\n"] }]
        }], ctorParameters: function () { return []; }, propDecorators: { color: [{
                type: Input
            }], _labels: [{
                type: Input
            }], _indexActivated: [{
                type: Input
            }], indexActivatedChange: [{
                type: Output
            }] } });

class BasicFiltersComponent {
    constructor() {
        this.color = '';
        this.changeFilter = new EventEmitter();
        this.state = {
            contrast: 1,
            blur: 0,
            brightness: 1,
            grayscale: 0,
            invert: 0,
            saturate: 1,
            sepia: 0,
        };
        this.debounce = (callback, delay) => {
            clearTimeout(this.timeout);
            this.timeout = setTimeout(() => {
                callback();
                clearTimeout(this.timeout);
            }, delay);
        };
    }
    set filterState(value) {
        if (value) {
            this.state = JSON.parse(JSON.stringify(Object.assign(Object.assign({}, this.state), value)));
        }
        else {
            this.state = {
                contrast: 1,
                blur: 0,
                brightness: 1,
                grayscale: 0,
                invert: 0,
                saturate: 1,
                sepia: 0,
            };
        }
    }
    ngOnInit() { }
    onChange() {
        this.debounce(() => {
            this.changeFilter.next(this.state);
        }, 150);
    }
}
BasicFiltersComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: BasicFiltersComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
BasicFiltersComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: BasicFiltersComponent, selector: "lib-basic-filters", inputs: { color: "color", labels: "labels", filterState: "filterState" }, outputs: { changeFilter: "changeFilter" }, ngImport: i0, template: "<div style=\"display: flex; width: 100%; justify-content: space-between\">\n  <p class=\"item-panel\">{{ labels['Contrast'] }}</p>\n  <p class=\"item-panel\">{{ (this.state?.contrast || 0.0).toFixed(2) }}</p>\n</div>\n<div style=\"flex-direction: row; box-sizing: border-box; display: flex; place-content: flex-start; align-items: flex-start\">\n  <input\n    class=\"input-range\"\n    (input)=\"onChange()\"\n    [ngStyle]=\"{ maxWidth: '100%', width: '100%', color: color }\"\n    [(ngModel)]=\"state.contrast\"\n    type=\"range\"\n    min=\"0\"\n    max=\"5\"\n    step=\"0.01\"\n  />\n</div>\n\n<br />\n<div style=\"display: flex; width: 100%; justify-content: space-between\">\n  <p class=\"item-panel\">{{ labels['Brightness'] }}</p>\n  <p class=\"item-panel\">{{ (this.state?.brightness || 0.0).toFixed(2) }}</p>\n</div>\n\n<div style=\"flex-direction: row; box-sizing: border-box; display: flex; place-content: flex-start; align-items: flex-start\">\n  <input\n    class=\"input-range\"\n    (input)=\"onChange()\"\n    [ngStyle]=\"{ maxWidth: '100%', width: '100%', color: color }\"\n    [(ngModel)]=\"state.brightness\"\n    type=\"range\"\n    min=\"0\"\n    max=\"5\"\n    step=\"0.01\"\n  />\n</div>\n\n<br />\n<div style=\"display: flex; width: 100%; justify-content: space-between\">\n  <p class=\"item-panel\">{{ labels['Grayscale'] }}</p>\n  <p class=\"item-panel\">{{ (this.state?.grayscale || 0.0).toFixed(2) }}</p>\n</div>\n\n<div style=\"flex-direction: row; box-sizing: border-box; display: flex; place-content: flex-start; align-items: flex-start\">\n  <input\n    class=\"input-range\"\n    (input)=\"onChange()\"\n    [ngStyle]=\"{ maxWidth: '100%', width: '100%', color: color }\"\n    [(ngModel)]=\"state.grayscale\"\n    type=\"range\"\n    min=\"0\"\n    max=\"1\"\n    step=\"0.01\"\n  />\n</div>\n\n<br />\n<div style=\"display: flex; width: 100%; justify-content: space-between\">\n  <p class=\"item-panel\">{{ labels['Saturate'] }}</p>\n  <p class=\"item-panel\">{{ (this.state?.saturate || 0.0).toFixed(2) }}</p>\n</div>\n\n<div style=\"flex-direction: row; box-sizing: border-box; display: flex; place-content: flex-start; align-items: flex-start\">\n  <input\n    class=\"input-range\"\n    (input)=\"onChange()\"\n    [ngStyle]=\"{ maxWidth: '100%', width: '100%', color: color }\"\n    [(ngModel)]=\"state.saturate\"\n    type=\"range\"\n    min=\"0\"\n    max=\"10\"\n    step=\"0.01\"\n  />\n</div>\n<br />\n<div style=\"display: flex; width: 100%; justify-content: space-between\">\n  <p class=\"item-panel\">{{ labels['Sepia'] }}</p>\n  <p class=\"item-panel\">{{ (this.state?.sepia || 0.0).toFixed(2) }}</p>\n</div>\n\n<div style=\"flex-direction: row; box-sizing: border-box; display: flex; place-content: flex-start; align-items: flex-start\">\n  <input\n    class=\"input-range\"\n    (input)=\"onChange()\"\n    [ngStyle]=\"{ maxWidth: '100%', width: '100%', color: color }\"\n    [(ngModel)]=\"state.sepia\"\n    type=\"range\"\n    min=\"0\"\n    max=\"1\"\n    step=\"0.01\"\n  />\n</div>\n\n<!-- <br />\n<div style=\"display: flex; width: 100%; justify-content: space-between\">\n  <p class=\"item-panel\">{{ labels['Invert'] }}</p>\n  <p class=\"item-panel\">{{ (this.state?.invert || 0.0).toFixed(2) }}</p>\n</div>\n\n<div style=\"flex-direction: row; box-sizing: border-box; display: flex; place-content: flex-start; align-items: flex-start\">\n  <input\n    class=\"input-range\"\n    (input)=\"onChange()\"\n    [ngStyle]=\"{ maxWidth: '100%', width: '100%', color: color }\"\n    [(ngModel)]=\"state.invert\"\n    type=\"range\"\n    min=\"0\"\n    max=\"1\"\n    step=\"0.01\"\n  />\n</div> -->\n\n<br />\n<div style=\"display: flex; width: 100%; justify-content: space-between\">\n  <p class=\"item-panel\">{{ labels['Blur'] }}</p>\n  <p class=\"item-panel\">{{ (state?.blur || 0.0).toFixed(2) }}</p>\n</div>\n\n<div style=\"flex-direction: row; box-sizing: border-box; display: flex; place-content: flex-start; align-items: flex-start\">\n  <input\n    class=\"input-range\"\n    (input)=\"onChange()\"\n    [ngStyle]=\"{ maxWidth: '100%', width: '100%', color: color }\"\n    [(ngModel)]=\"state.blur\"\n    type=\"range\"\n    min=\"0\"\n    max=\"20\"\n    step=\"1\"\n  />\n</div>\n", styles: [""], dependencies: [{ kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: i2.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2.RangeValueAccessor, selector: "input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]" }, { kind: "directive", type: i2.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: BasicFiltersComponent, decorators: [{
            type: Component,
            args: [{ selector: 'lib-basic-filters', template: "<div style=\"display: flex; width: 100%; justify-content: space-between\">\n  <p class=\"item-panel\">{{ labels['Contrast'] }}</p>\n  <p class=\"item-panel\">{{ (this.state?.contrast || 0.0).toFixed(2) }}</p>\n</div>\n<div style=\"flex-direction: row; box-sizing: border-box; display: flex; place-content: flex-start; align-items: flex-start\">\n  <input\n    class=\"input-range\"\n    (input)=\"onChange()\"\n    [ngStyle]=\"{ maxWidth: '100%', width: '100%', color: color }\"\n    [(ngModel)]=\"state.contrast\"\n    type=\"range\"\n    min=\"0\"\n    max=\"5\"\n    step=\"0.01\"\n  />\n</div>\n\n<br />\n<div style=\"display: flex; width: 100%; justify-content: space-between\">\n  <p class=\"item-panel\">{{ labels['Brightness'] }}</p>\n  <p class=\"item-panel\">{{ (this.state?.brightness || 0.0).toFixed(2) }}</p>\n</div>\n\n<div style=\"flex-direction: row; box-sizing: border-box; display: flex; place-content: flex-start; align-items: flex-start\">\n  <input\n    class=\"input-range\"\n    (input)=\"onChange()\"\n    [ngStyle]=\"{ maxWidth: '100%', width: '100%', color: color }\"\n    [(ngModel)]=\"state.brightness\"\n    type=\"range\"\n    min=\"0\"\n    max=\"5\"\n    step=\"0.01\"\n  />\n</div>\n\n<br />\n<div style=\"display: flex; width: 100%; justify-content: space-between\">\n  <p class=\"item-panel\">{{ labels['Grayscale'] }}</p>\n  <p class=\"item-panel\">{{ (this.state?.grayscale || 0.0).toFixed(2) }}</p>\n</div>\n\n<div style=\"flex-direction: row; box-sizing: border-box; display: flex; place-content: flex-start; align-items: flex-start\">\n  <input\n    class=\"input-range\"\n    (input)=\"onChange()\"\n    [ngStyle]=\"{ maxWidth: '100%', width: '100%', color: color }\"\n    [(ngModel)]=\"state.grayscale\"\n    type=\"range\"\n    min=\"0\"\n    max=\"1\"\n    step=\"0.01\"\n  />\n</div>\n\n<br />\n<div style=\"display: flex; width: 100%; justify-content: space-between\">\n  <p class=\"item-panel\">{{ labels['Saturate'] }}</p>\n  <p class=\"item-panel\">{{ (this.state?.saturate || 0.0).toFixed(2) }}</p>\n</div>\n\n<div style=\"flex-direction: row; box-sizing: border-box; display: flex; place-content: flex-start; align-items: flex-start\">\n  <input\n    class=\"input-range\"\n    (input)=\"onChange()\"\n    [ngStyle]=\"{ maxWidth: '100%', width: '100%', color: color }\"\n    [(ngModel)]=\"state.saturate\"\n    type=\"range\"\n    min=\"0\"\n    max=\"10\"\n    step=\"0.01\"\n  />\n</div>\n<br />\n<div style=\"display: flex; width: 100%; justify-content: space-between\">\n  <p class=\"item-panel\">{{ labels['Sepia'] }}</p>\n  <p class=\"item-panel\">{{ (this.state?.sepia || 0.0).toFixed(2) }}</p>\n</div>\n\n<div style=\"flex-direction: row; box-sizing: border-box; display: flex; place-content: flex-start; align-items: flex-start\">\n  <input\n    class=\"input-range\"\n    (input)=\"onChange()\"\n    [ngStyle]=\"{ maxWidth: '100%', width: '100%', color: color }\"\n    [(ngModel)]=\"state.sepia\"\n    type=\"range\"\n    min=\"0\"\n    max=\"1\"\n    step=\"0.01\"\n  />\n</div>\n\n<!-- <br />\n<div style=\"display: flex; width: 100%; justify-content: space-between\">\n  <p class=\"item-panel\">{{ labels['Invert'] }}</p>\n  <p class=\"item-panel\">{{ (this.state?.invert || 0.0).toFixed(2) }}</p>\n</div>\n\n<div style=\"flex-direction: row; box-sizing: border-box; display: flex; place-content: flex-start; align-items: flex-start\">\n  <input\n    class=\"input-range\"\n    (input)=\"onChange()\"\n    [ngStyle]=\"{ maxWidth: '100%', width: '100%', color: color }\"\n    [(ngModel)]=\"state.invert\"\n    type=\"range\"\n    min=\"0\"\n    max=\"1\"\n    step=\"0.01\"\n  />\n</div> -->\n\n<br />\n<div style=\"display: flex; width: 100%; justify-content: space-between\">\n  <p class=\"item-panel\">{{ labels['Blur'] }}</p>\n  <p class=\"item-panel\">{{ (state?.blur || 0.0).toFixed(2) }}</p>\n</div>\n\n<div style=\"flex-direction: row; box-sizing: border-box; display: flex; place-content: flex-start; align-items: flex-start\">\n  <input\n    class=\"input-range\"\n    (input)=\"onChange()\"\n    [ngStyle]=\"{ maxWidth: '100%', width: '100%', color: color }\"\n    [(ngModel)]=\"state.blur\"\n    type=\"range\"\n    min=\"0\"\n    max=\"20\"\n    step=\"1\"\n  />\n</div>\n" }]
        }], ctorParameters: function () { return []; }, propDecorators: { color: [{
                type: Input
            }], labels: [{
                type: Input
            }], changeFilter: [{
                type: Output
            }], filterState: [{
                type: Input
            }] } });

"use strict";
/**
 * POLYFILLS
 */
// Request Animation Frame polyfill
(function () {
    let lastTime = 0;
    let vendors = ['ms', 'moz', 'webkit', 'o'];
    for (let x = 0; x < vendors.length && !window.requestAnimationFrame; x++) {
        window.requestAnimationFrame = window[(vendors[x] + 'RequestAnimationFrame')];
        window.cancelAnimationFrame = (window[(vendors[x] + 'CancelAnimationFrame')] ||
            window[(vendors[x] + 'CancelRequestAnimationFrame')]);
    }
    if (!window.requestAnimationFrame)
        window.requestAnimationFrame = function (callback, element) {
            let currTime = new Date().getTime();
            let timeToCall = Math.max(0, 16 - (currTime - lastTime));
            let id = window.setTimeout(function () {
                callback(currTime + timeToCall);
            }, timeToCall);
            lastTime = currTime + timeToCall;
            return id;
        };
    if (!window.cancelAnimationFrame)
        window.cancelAnimationFrame = function (id) {
            clearTimeout(id);
        };
})();
// CustomEvents polyfill
(function () {
    if (typeof window.CustomEvent === 'function')
        return false;
    function CustomEvent(event, params) {
        params = params || { bubbles: false, cancelable: false, detail: undefined };
        let evt = document.createEvent('CustomEvent');
        evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
        return evt;
    }
    CustomEvent.prototype = window.Event.prototype;
    window.CustomEvent = CustomEvent;
})();
// MouseEvents polyfill
(function (window) {
    try {
        new CustomEvent('test');
        return false; // No need to polyfill
    }
    catch (e) {
        // Need to polyfill - fall through
    }
    // Polyfills DOM4 CustomEvent
    function MouseEvent(eventType, params) {
        params = params || { bubbles: false, cancelable: false };
        let mouseEvent = document.createEvent('MouseEvent');
        mouseEvent.initMouseEvent(eventType, params.bubbles, params.cancelable, window, 0, 0, 0, 0, 0, false, false, false, false, 0, null);
        return mouseEvent;
    }
    MouseEvent.prototype = Event.prototype;
    window.MouseEvent = MouseEvent;
})(window);

/**
 * Handle component
 */
class Handle {
    constructor(position, constraints, cursor, eventBus) {
        var self = this;
        this.position = position;
        this.constraints = constraints;
        this.cursor = cursor;
        this.eventBus = eventBus;
        // Create DOM element
        this.el = document.createElement("div");
        this.el.className = "croppr-handle";
        this.el.style.cursor = cursor;
        // Attach initial listener
        this.el.addEventListener("mousedown", onMouseDown);
        function onMouseDown(e) {
            e.stopPropagation();
            document.addEventListener("mouseup", onMouseUp);
            document.addEventListener("mousemove", onMouseMove);
            // Notify parent
            self.eventBus.dispatchEvent(new CustomEvent("handlestart", {
                detail: { handle: self },
            }));
        }
        function onMouseUp(e) {
            e.stopPropagation();
            document.removeEventListener("mouseup", onMouseUp);
            document.removeEventListener("mousemove", onMouseMove);
            // Notify parent
            self.eventBus.dispatchEvent(new CustomEvent("handleend", {
                detail: { handle: self },
            }));
        }
        function onMouseMove(e) {
            e.stopPropagation();
            // Notify parent
            self.eventBus.dispatchEvent(new CustomEvent("handlemove", {
                detail: { mouseX: e.clientX, mouseY: e.clientY },
            }));
        }
    }
}

/**
 * Box component
 */
class Box {
    constructor(x1, y1, x2, y2) {
        this.x1 = x1;
        this.y1 = y1;
        this.x2 = x2;
        this.y2 = y2;
    }
    /**
     * Sets the new dimensions of the box.
     * @param {Number} x1
     * @param {Number} y1
     * @param {Number} x2
     * @param {Number} y2
     */
    set(x1 = null, y1 = null, x2 = null, y2 = null) {
        this.x1 = x1 == null ? this.x1 : x1;
        this.y1 = y1 == null ? this.y1 : y1;
        this.x2 = x2 == null ? this.x2 : x2;
        this.y2 = y2 == null ? this.y2 : y2;
        return this;
    }
    /**
     * Calculates the width of the box.
     * @returns {Number}
     */
    width() {
        return Math.abs(this.x2 - this.x1);
    }
    /**
     * Calculates the height of the box.
     * @returns {Number}
     */
    height() {
        return Math.abs(this.y2 - this.y1);
    }
    /**
     * Resizes the box to a new size.
     * @param {Number} newWidth
     * @param {Number} newHeight
     * @param {Array} [origin] The origin point to resize from.
     *      Defaults to [0, 0] (top left).
     */
    resize(newWidth, newHeight, origin = [0, 0]) {
        const fromX = this.x1 + this.width() * origin[0];
        const fromY = this.y1 + this.height() * origin[1];
        this.x1 = fromX - newWidth * origin[0];
        this.y1 = fromY - newHeight * origin[1];
        this.x2 = this.x1 + newWidth;
        this.y2 = this.y1 + newHeight;
        return this;
    }
    /**
     * Scale the box by a factor.
     * @param {Number} factor
     * @param {Array} [origin] The origin point to resize from.
     *      Defaults to [0, 0] (top left).
     */
    scale(factor, origin = [0, 0]) {
        const newWidth = this.width() * factor;
        const newHeight = this.height() * factor;
        this.resize(newWidth, newHeight, origin);
        return this;
    }
    /**
     * Move the box to the specified coordinates.
     */
    move(x = null, y = null) {
        let width = this.width();
        let height = this.height();
        x = x === null ? this.x1 : x;
        y = y === null ? this.y1 : y;
        this.x1 = x;
        this.y1 = y;
        this.x2 = x + width;
        this.y2 = y + height;
        return this;
    }
    /**
     * Get relative x and y coordinates of a given point within the box.
     * @param {Array} point The x and y ratio position within the box.
     * @returns {Array} The x and y coordinates [x, y].
     */
    getRelativePoint(point = [0, 0]) {
        const x = this.width() * point[0];
        const y = this.height() * point[1];
        return [x, y];
    }
    /**
     * Get absolute x and y coordinates of a given point within the box.
     * @param {Array} point The x and y ratio position within the box.
     * @returns {Array} The x and y coordinates [x, y].
     */
    getAbsolutePoint(point = [0, 0]) {
        const x = this.x1 + this.width() * point[0];
        const y = this.y1 + this.height() * point[1];
        return [x, y];
    }
    /**
     * Constrain the box to a fixed ratio.
     * @param {Number} ratio
     * @param {Array} [origin] The origin point to resize from.
     *     Defaults to [0, 0] (top left).
     * @param {String} [grow] The axis to grow to maintain the ratio.
     *     Defaults to 'height'.
     */
    constrainToRatio(ratio, origin = [0, 0], grow = "height") {
        if (ratio === null) {
            return;
        }
        const width = this.width();
        const height = this.height();
        switch (grow) {
            case "height": // Grow height only
                this.resize(this.width(), this.width() * ratio, origin);
                break;
            case "width": // Grow width only
                this.resize((this.height() * 1) / ratio, this.height(), origin);
                break;
            default: // Default: Grow height only
                this.resize(this.width(), this.width() * ratio, origin);
        }
        return this;
    }
    /**
     * Constrain the box within a boundary.
     * @param {Number} boundaryWidth
     * @param {Number} boundaryHeight
     * @param {Array} [origin] The origin point to resize from.
     *     Defaults to [0, 0] (top left).
     */
    constrainToBoundary(boundaryWidth, boundaryHeight, origin = [0, 0]) {
        // Calculate the maximum sizes for each direction of growth
        const [originX, originY] = this.getAbsolutePoint(origin);
        const maxIfLeft = originX;
        const maxIfTop = originY;
        const maxIfRight = boundaryWidth - originX;
        const maxIfBottom = boundaryHeight - originY;
        // Express the direction of growth in terms of left, both,
        // and right as -1, 0, and 1 respectively. Ditto for top/both/down.
        const directionX = -2 * origin[0] + 1;
        const directionY = -2 * origin[1] + 1;
        // Determine the max size to use according to the direction of growth.
        let [maxWidth, maxHeight] = [null, null];
        switch (directionX) {
            case -1:
                maxWidth = maxIfLeft;
                break;
            case 0:
                maxWidth = (Math.min(maxIfLeft, maxIfRight) * 2);
                break;
            case +1:
                maxWidth = maxIfRight;
                break;
        }
        switch (directionY) {
            case -1:
                maxHeight = maxIfTop;
                break;
            case 0:
                maxHeight = (Math.min(maxIfTop, maxIfBottom) * 2);
                break;
            case +1:
                maxHeight = maxIfBottom;
                break;
        }
        // Resize if the box exceeds the calculated max width/height.
        if (this.width() > maxWidth) {
            const factor = maxWidth / this.width();
            this.scale(factor, origin);
        }
        if (this.height() > maxHeight) {
            const factor = maxHeight / this.height();
            this.scale(factor, origin);
        }
        return this;
    }
    /**
     * Constrain the box to a maximum/minimum size.
     * @param {Number} [maxWidth]
     * @param {Number} [maxHeight]
     * @param {Number} [minWidth]
     * @param {Number} [minHeight]
     * @param {Array} [origin] The origin point to resize from.
     *     Defaults to [0, 0] (top left).
     * @param {Number} [ratio] Ratio to maintain.
     */
    constrainToSize(maxWidth = null, maxHeight = null, minWidth = null, minHeight = null, origin = [0, 0], ratio = null) {
        // Calculate new max/min widths & heights that constrains to the ratio
        if (ratio) {
            if (ratio > 1) {
                maxWidth = (maxHeight * 1) / ratio;
                minHeight = minHeight * ratio;
            }
            else if (ratio < 1) {
                maxHeight = maxWidth * ratio;
                minWidth = (minHeight * 1) / ratio;
            }
        }
        if (maxWidth && this.width() > maxWidth) {
            const newWidth = maxWidth, newHeight = ratio === null ? this.height() : maxHeight;
            this.resize(newWidth, newHeight, origin);
        }
        if (maxHeight && this.height() > maxHeight) {
            const newWidth = ratio === null ? this.width() : maxWidth, newHeight = maxHeight;
            this.resize(newWidth, newHeight, origin);
        }
        if (minWidth && this.width() < minWidth) {
            const newWidth = minWidth, newHeight = ratio === null ? this.height() : minHeight;
            this.resize(newWidth, newHeight, origin);
        }
        if (minHeight && this.height() < minHeight) {
            const newWidth = ratio === null ? this.width() : minWidth, newHeight = minHeight;
            this.resize(newWidth, newHeight, origin);
        }
        return this;
    }
}

/**
 * Croppr Touch
 * Enables support for touch devices by translating touch events to
 * mouse events.
 */
/**
 * Binds an element's touch events to be simulated as mouse events.
 * @param {Element} element
 */
function enableTouch(element) {
    element.addEventListener('touchstart', simulateMouseEvent);
    element.addEventListener('touchend', simulateMouseEvent);
    element.addEventListener('touchmove', simulateMouseEvent);
}
/**
 * Translates a touch event to a mouse event.
 * @param {Event} e
 */
function simulateMouseEvent(e) {
    e.preventDefault();
    const touch = e.changedTouches[0];
    const eventMap = {
        touchstart: 'mousedown',
        touchmove: 'mousemove',
        touchend: 'mouseup',
    };
    touch.target.dispatchEvent(new MouseEvent(eventMap[e.type], {
        bubbles: true,
        cancelable: true,
        view: window,
        clientX: touch.clientX,
        clientY: touch.clientY,
        screenX: touch.screenX,
        screenY: touch.screenY,
    }));
}

/**
 * CropprCore
 * Here lies the main logic.
 */
/**
 * Define a list of handles to create.
 *
 * @property {Array} position - The x and y ratio position of the handle within
 *      the crop region. Accepts a value between 0 to 1 in the order of [X, Y].
 * @property {Array} constraints - Define the side of the crop region that is to
 *      be affected by this handle. Accepts a value of 0 or 1 in the order of
 *      [TOP, RIGHT, BOTTOM, LEFT].
 * @property {String} cursor - The CSS cursor of this handle.
 */
const HANDLES = [
    { position: [0.0, 0.0], constraints: [1, 0, 0, 1], cursor: 'nw-resize' },
    { position: [0.5, 0.0], constraints: [1, 0, 0, 0], cursor: 'n-resize' },
    { position: [1.0, 0.0], constraints: [1, 1, 0, 0], cursor: 'ne-resize' },
    { position: [1.0, 0.5], constraints: [0, 1, 0, 0], cursor: 'e-resize' },
    { position: [1.0, 1.0], constraints: [0, 1, 1, 0], cursor: 'se-resize' },
    { position: [0.5, 1.0], constraints: [0, 0, 1, 0], cursor: 's-resize' },
    { position: [0.0, 1.0], constraints: [0, 0, 1, 1], cursor: 'sw-resize' },
    { position: [0.0, 0.5], constraints: [0, 0, 0, 1], cursor: 'w-resize' },
];
/**
 * Core class for Croppr containing most of its functional logic.
 */
class CropprCore {
    constructor(element, options, deferred = false) {
        this.regionEl = null;
        // console.log("🚀 ~ file: core.ts ~ line 51 ~ CropprCore ~ constructor ~ element", element)
        // Parse options
        this.options = CropprCore.parseOptions(options || {});
        // Get target img element
        if (!element.nodeName) {
            element = document.querySelector(element);
            // console.log("🚀 ~ file: core.ts ~ line 58 ~ CropprCore ~ constructor ~ element", element)
            if (element == null) {
                throw 'Unable to find element.';
            }
        }
        if (!element.getAttribute('src')) {
            throw 'Image src not provided.';
        }
        // Define internal props
        this._initialized = false;
        this._restore = {
            parent: element.parentNode,
            element: element,
        };
        // Wait until image is loaded before proceeding
        if (!deferred) {
            if (element.width === 0 || element.height === 0) {
                element.onload = () => {
                    this.initialize(element);
                };
            }
            else {
                this.initialize(element);
            }
        }
    }
    /**
     * Initialize the Croppr instance
     */
    initialize(element) {
        // Create DOM elements
        this.createDOM(element);
        // Process option values
        this.options.convertToPixels(this.cropperEl);
        // Listen for events from children
        this.attachHandlerEvents();
        this.attachRegionEvents();
        this.attachOverlayEvents();
        // Bootstrap this cropper instance
        this.box = this.initializeBox(this.options);
        this.redraw();
        // Set the initalized flag to true and call the callback
        this._initialized = true;
        if (this.options.onInitialize !== null) {
            this.options.onInitialize(this);
        }
    }
    /**
     * Create Croppr's DOM elements
     */
    createDOM(targetEl) {
        // Create main container and use it as the main event listeners
        this.containerEl = document.createElement('div');
        this.containerEl.className = 'croppr-container';
        this.eventBus = this.containerEl;
        enableTouch(this.containerEl);
        // Create cropper element
        this.cropperEl = document.createElement('div');
        this.cropperEl.className = 'croppr';
        // Create image element
        this.imageEl = document.createElement('img');
        this.imageEl.setAttribute('src', targetEl.getAttribute('src'));
        this.imageEl.setAttribute('alt', targetEl.getAttribute('alt'));
        this.imageEl.className = 'croppr-image';
        // Create clipped image element
        this.imageClippedEl = this.imageEl.cloneNode();
        this.imageClippedEl.className = 'croppr-imageClipped';
        // Create region box element
        this.regionEl = document.createElement('div');
        this.regionEl.innerHTML = new Array(9)
            .fill(1)
            .map(() => `<div style="border: 1px dashed #fafafa"></div>`)
            .join('');
        this.regionEl.className = 'croppr-region';
        // Create overlay element
        this.overlayEl = document.createElement('div');
        this.overlayEl.className = 'croppr-overlay';
        // Create handles element
        let handleContainerEl = document.createElement('div');
        handleContainerEl.className = 'croppr-handleContainer';
        this.handles = [];
        for (let i = 0; i < HANDLES.length; i++) {
            const handle = new Handle(HANDLES[i].position, HANDLES[i].constraints, HANDLES[i].cursor, this.eventBus);
            this.handles.push(handle);
            handleContainerEl.appendChild(handle.el);
        }
        // And then we piece it all together!
        this.cropperEl.appendChild(this.imageEl);
        this.cropperEl.appendChild(this.imageClippedEl);
        this.cropperEl.appendChild(this.regionEl);
        this.cropperEl.appendChild(this.overlayEl);
        this.cropperEl.appendChild(handleContainerEl);
        this.containerEl.appendChild(this.cropperEl);
        // And then finally insert it into the document
        targetEl.parentElement.replaceChild(this.containerEl, targetEl);
    }
    /**
     * Changes the image src.
     * @param {String} src
     */
    setImage(src) {
        // Add onload listener to reinitialize box
        this.imageEl.onload = () => {
            this.box = this.initializeBox(this.options);
            this.redraw();
        };
        // Change image source
        this.imageEl.src = src;
        this.imageClippedEl.src = src;
        return this;
    }
    /**
     * Destroy the Croppr instance and replace with the original element.
     */
    destroy() {
        this._restore.parent.replaceChild(this._restore.element, this.containerEl);
    }
    /**
     * Create a new box region with a set of options.
     * @param {Object} opts The options.
     * @returns {Box}
     */
    initializeBox(opts) {
        // Create initial box
        const width = opts.startSize.width;
        const height = opts.startSize.height;
        let box = new Box(0, 0, width, height);
        // console.log("🚀 ~ file: core.ts ~ line 202 ~ CropprCore ~ initializeBox ~ box", box)
        // Maintain ratio
        box.constrainToRatio(opts.aspectRatio, [0.5, 0.5]);
        // Maintain minimum/maximum size
        const min = opts.minSize;
        const max = opts.maxSize;
        box.constrainToSize(max.width, max.height, min.width, min.height, [0.5, 0.5], opts.aspectRatio);
        // Constrain to boundary
        const parentWidth = this.cropperEl.offsetWidth;
        const parentHeight = this.cropperEl.offsetHeight;
        box.constrainToBoundary(parentWidth, parentHeight, [0.5, 0.5]);
        // // Move to center
        const x = this.cropperEl.offsetWidth / 2 - box.width() / 2;
        const y = this.cropperEl.offsetHeight / 2 - box.height() / 2;
        // console.log("🚀 ~ file: core.ts ~ line 219 ~ CropprCore ~ initializeBox ~ this.cropperEl", this.cropperEl.offsetWidth)
        // console.log("🚀 ~ file: core.ts ~ line 223 ~ CropprCore ~ initializeBox ~ x, y", x, y)
        box.move(x, y);
        return box;
    }
    /**
     * Draw visuals (border, handles, etc) for the current box.
     */
    redraw() {
        // Round positional values to prevent subpixel coordinates, which can
        // result in element that is rendered blurly
        const width = Math.round(this.box.width()), height = Math.round(this.box.height()), x1 = Math.round(this.box.x1), y1 = Math.round(this.box.y1), x2 = Math.round(this.box.x2), y2 = Math.round(this.box.y2);
        window.requestAnimationFrame(() => {
            // Update region element
            if (!this.regionEl)
                return;
            this.regionEl.style.transform = `translate(${x1}px, ${y1}px)`;
            this.regionEl.style.width = width + 'px';
            this.regionEl.style.height = height + 'px';
            // Update clipped image element
            this.imageClippedEl.style.clip = `rect(${y1}px, ${x2}px, ${y2}px, ${x1}px)`;
            // Determine which handle to bring forward. The following code
            // calculates the quadrant the box is in using bitwise operators.
            // Reference: https://stackoverflow.com/questions/9718059
            const center = this.box.getAbsolutePoint([0.5, 0.5]);
            const xSign = (center[0] - this.cropperEl.offsetWidth / 2) >> 31;
            const ySign = (center[1] - this.cropperEl.offsetHeight / 2) >> 31;
            const quadrant = (xSign ^ ySign) + ySign + ySign + 4;
            // The following equation calculates which handle index to bring
            // forward. The equation is derived using algebra (if youre curious)
            const foregroundHandleIndex = -2 * quadrant + 8;
            // Update handle positions
            for (let i = 0; i < this.handles.length; i++) {
                let handle = this.handles[i];
                // Calculate handle position
                const handleWidth = handle.el.offsetWidth;
                const handleHeight = handle.el.offsetHeight;
                const left = x1 + width * handle.position[0] - handleWidth / 2;
                const top = y1 + height * handle.position[1] - handleHeight / 2;
                // Apply new position. The positional values are rounded to
                // prevent subpixel positions which can result in a blurry element
                handle.el.style.transform = `translate(${Math.round(left)}px, ${Math.round(top)}px)`;
                handle.el.style.zIndex = foregroundHandleIndex == i ? 5 : 4;
            }
        });
    }
    /**
     * Attach listeners for events emitted by the handles.
     * Enables resizing of the region element.
     */
    attachHandlerEvents() {
        const eventBus = this.eventBus;
        eventBus.addEventListener('handlestart', this.onHandleMoveStart.bind(this));
        eventBus.addEventListener('handlemove', this.onHandleMoveMoving.bind(this));
        eventBus.addEventListener('handleend', this.onHandleMoveEnd.bind(this));
    }
    /**
     * Attach event listeners for the crop region element.
     * Enables dragging/moving of the region element.
     */
    attachRegionEvents() {
        const eventBus = this.eventBus;
        const self = this;
        if (!this.regionEl)
            return;
        this.regionEl.addEventListener('mousedown', onMouseDown);
        eventBus.addEventListener('regionstart', this.onRegionMoveStart.bind(this));
        eventBus.addEventListener('regionmove', this.onRegionMoveMoving.bind(this));
        eventBus.addEventListener('regionend', this.onRegionMoveEnd.bind(this));
        function onMouseDown(e) {
            e.stopPropagation();
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('mousemove', onMouseMove);
            // Notify parent
            eventBus.dispatchEvent(new CustomEvent('regionstart', {
                detail: { mouseX: e.clientX, mouseY: e.clientY },
            }));
        }
        function onMouseMove(e) {
            e.stopPropagation();
            // Notify parent
            eventBus.dispatchEvent(new CustomEvent('regionmove', {
                detail: { mouseX: e.clientX, mouseY: e.clientY },
            }));
        }
        function onMouseUp(e) {
            e.stopPropagation();
            document.removeEventListener('mouseup', onMouseUp);
            document.removeEventListener('mousemove', onMouseMove);
            // Notify parent
            eventBus.dispatchEvent(new CustomEvent('regionend', {
                detail: { mouseX: e.clientX, mouseY: e.clientY },
            }));
        }
    }
    /**
     * Attach event listeners for the overlay element.
     * Enables the creation of a new selection by dragging an empty area.
     */
    attachOverlayEvents() {
        const SOUTHEAST_HANDLE_IDX = 4;
        const self = this;
        let tmpBox = null;
        this.overlayEl.addEventListener('mousedown', onMouseDown);
        function onMouseDown(e) {
            e.stopPropagation();
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('mousemove', onMouseMove);
            // Calculate mouse's position in relative to the container
            const container = self.cropperEl.getBoundingClientRect();
            const mouseX = e.clientX - container.left;
            const mouseY = e.clientY - container.top;
            // Create new box at mouse position
            tmpBox = self.box;
            self.box = new Box(mouseX, mouseY, mouseX + 1, mouseY + 1);
            // Activate the bottom right handle
            self.eventBus.dispatchEvent(new CustomEvent('handlestart', {
                detail: { handle: self.handles[SOUTHEAST_HANDLE_IDX] },
            }));
        }
        function onMouseMove(e) {
            e.stopPropagation();
            self.eventBus.dispatchEvent(new CustomEvent('handlemove', {
                detail: { mouseX: e.clientX, mouseY: e.clientY },
            }));
        }
        function onMouseUp(e) {
            e.stopPropagation();
            document.removeEventListener('mouseup', onMouseUp);
            document.removeEventListener('mousemove', onMouseMove);
            // If the new box has no width and height, it suggests that
            // the user had just clicked on an empty area and did not drag
            // a new box (ie. an accidental click). In this scenario, we
            // simply replace it with the previous box.
            if (self.box.width() === 1 && self.box.height() === 1) {
                self.box = tmpBox;
                return;
            }
            self.eventBus.dispatchEvent(new CustomEvent('handleend', {
                detail: { mouseX: e.clientX, mouseY: e.clientY },
            }));
        }
    }
    /**
     * EVENT HANDLER
     * Executes when user begins dragging a handle.
     */
    onHandleMoveStart(e) {
        let handle = e.detail.handle;
        // The origin point is the point where the box is scaled from.
        // This is usually the opposite side/corner of the active handle.
        const originPoint = [1 - handle.position[0], 1 - handle.position[1]];
        let [originX, originY] = this.box.getAbsolutePoint(originPoint);
        this.activeHandle = { handle, originPoint, originX, originY };
        // Trigger callback
        if (this.options.onCropStart !== null) {
            this.options.onCropStart(this.getValue());
        }
    }
    /**
     * EVENT HANDLER
     * Executes on handle move. Main logic to manage the movement of handles.
     */
    onHandleMoveMoving(e) {
        let { mouseX, mouseY } = e.detail;
        // Calculate mouse's position in relative to the container
        let container = this.cropperEl.getBoundingClientRect();
        mouseX = mouseX - container.left;
        mouseY = mouseY - container.top;
        // Ensure mouse is within the boundaries
        if (mouseX < 0) {
            mouseX = 0;
        }
        else if (mouseX > container.width) {
            mouseX = container.width;
        }
        if (mouseY < 0) {
            mouseY = 0;
        }
        else if (mouseY > container.height) {
            mouseY = container.height;
        }
        // Bootstrap helper variables
        let origin = this.activeHandle.originPoint.slice();
        const originX = this.activeHandle.originX;
        const originY = this.activeHandle.originY;
        const handle = this.activeHandle.handle;
        const TOP_MOVABLE = handle.constraints[0] === 1;
        const RIGHT_MOVABLE = handle.constraints[1] === 1;
        const BOTTOM_MOVABLE = handle.constraints[2] === 1;
        const LEFT_MOVABLE = handle.constraints[3] === 1;
        const MULTI_AXIS = (LEFT_MOVABLE || RIGHT_MOVABLE) && (TOP_MOVABLE || BOTTOM_MOVABLE);
        // Apply movement to respective sides according to the handle's
        // constraint values.
        let x1 = LEFT_MOVABLE || RIGHT_MOVABLE ? originX : this.box.x1;
        let x2 = LEFT_MOVABLE || RIGHT_MOVABLE ? originX : this.box.x2;
        let y1 = TOP_MOVABLE || BOTTOM_MOVABLE ? originY : this.box.y1;
        let y2 = TOP_MOVABLE || BOTTOM_MOVABLE ? originY : this.box.y2;
        x1 = LEFT_MOVABLE ? mouseX : x1;
        x2 = RIGHT_MOVABLE ? mouseX : x2;
        y1 = TOP_MOVABLE ? mouseY : y1;
        y2 = BOTTOM_MOVABLE ? mouseY : y2;
        // Check if the user dragged past the origin point. If it did,
        // we set the flipped flag to true.
        let [isFlippedX, isFlippedY] = [false, false];
        if (LEFT_MOVABLE || RIGHT_MOVABLE) {
            isFlippedX = LEFT_MOVABLE ? mouseX > originX : mouseX < originX;
        }
        if (TOP_MOVABLE || BOTTOM_MOVABLE) {
            isFlippedY = TOP_MOVABLE ? mouseY > originY : mouseY < originY;
        }
        // If it is flipped, we swap the coordinates and flip the origin point.
        if (isFlippedX) {
            const tmp = x1;
            x1 = x2;
            x2 = tmp; // Swap x1 and x2
            origin[0] = 1 - origin[0]; // Flip origin x point
        }
        if (isFlippedY) {
            const tmp = y1;
            y1 = y2;
            y2 = tmp; // Swap y1 and y2
            origin[1] = 1 - origin[1]; // Flip origin y point
        }
        // Create new box object
        let box = new Box(x1, y1, x2, y2);
        // Maintain aspect ratio
        if (this.options.aspectRatio) {
            const ratio = this.options.aspectRatio;
            let isVerticalMovement = false;
            if (MULTI_AXIS) {
                isVerticalMovement = mouseY > box.y1 + ratio * box.width() || mouseY < box.y2 - ratio * box.width();
            }
            else if (TOP_MOVABLE || BOTTOM_MOVABLE) {
                isVerticalMovement = true;
            }
            const ratioMode = isVerticalMovement ? 'width' : 'height';
            box.constrainToRatio(ratio, origin, ratioMode);
        }
        // Maintain minimum/maximum size
        const min = this.options.minSize;
        const max = this.options.maxSize;
        box.constrainToSize(max.width, max.height, min.width, min.height, origin, this.options.aspectRatio);
        // Constrain to boundary
        const parentWidth = this.cropperEl.offsetWidth;
        const parentHeight = this.cropperEl.offsetHeight;
        box.constrainToBoundary(parentWidth, parentHeight, origin);
        // Finally, update the visuals (border, handles, clipped image, etc)
        this.box = box;
        this.redraw();
        // Trigger callback
        if (this.options.onCropMove !== null) {
            this.options.onCropMove(this.getValue());
        }
    }
    /**
     * EVENT HANDLER
     * Executes on handle move end.
     */
    onHandleMoveEnd(e) {
        // Trigger callback
        if (this.options.onCropEnd !== null) {
            this.options.onCropEnd(this.getValue());
        }
    }
    /**
     * EVENT HANDLER
     * Executes when user starts moving the crop region.
     */
    onRegionMoveStart(e) {
        let { mouseX, mouseY } = e.detail;
        // Calculate mouse's position in relative to the container
        let container = this.cropperEl.getBoundingClientRect();
        mouseX = mouseX - container.left;
        mouseY = mouseY - container.top;
        this.currentMove = {
            offsetX: mouseX - this.box.x1,
            offsetY: mouseY - this.box.y1,
        };
        // Trigger callback
        if (this.options.onCropStart !== null) {
            this.options.onCropStart(this.getValue());
        }
    }
    /**
     * EVENT HANDLER
     * Executes when user moves the crop region.
     */
    onRegionMoveMoving(e) {
        let { mouseX, mouseY } = e.detail;
        let { offsetX, offsetY } = this.currentMove;
        // Calculate mouse's position in relative to the container
        let container = this.cropperEl.getBoundingClientRect();
        mouseX = mouseX - container.left;
        mouseY = mouseY - container.top;
        this.box.move(mouseX - offsetX, mouseY - offsetY);
        // Ensure box is within the boundaries
        if (this.box.x1 < 0) {
            this.box.move(0, null);
        }
        if (this.box.x2 > container.width) {
            this.box.move(container.width - this.box.width(), null);
        }
        if (this.box.y1 < 0) {
            this.box.move(null, 0);
        }
        if (this.box.y2 > container.height) {
            this.box.move(null, container.height - this.box.height());
        }
        // Update visuals
        this.redraw();
        // Trigger callback
        if (this.options.onCropMove !== null) {
            this.options.onCropMove(this.getValue());
        }
    }
    /**
     * EVENT HANDLER
     * Executes when user stops moving the crop region (mouse up).
     */
    onRegionMoveEnd(e) {
        // Trigger callback
        if (this.options.onCropEnd !== null) {
            this.options.onCropEnd(this.getValue());
        }
    }
    /**
     * Calculate the value of the crop region.
     */
    getValue(mode = null) {
        if (mode === null) {
            mode = this.options.returnMode;
        }
        if (mode == 'real') {
            const actualWidth = this.imageEl.naturalWidth;
            const actualHeight = this.imageEl.naturalHeight;
            const { width: elementWidth, height: elementHeight } = this.imageEl.getBoundingClientRect();
            const factorX = actualWidth / elementWidth;
            const factorY = actualHeight / elementHeight;
            return {
                x: Math.round(this.box.x1 * factorX),
                y: Math.round(this.box.y1 * factorY),
                width: Math.round(this.box.width() * factorX),
                height: Math.round(this.box.height() * factorY),
            };
        }
        else if (mode == 'ratio') {
            const { width: elementWidth, height: elementHeight } = this.imageEl.getBoundingClientRect();
            return {
                x: round(this.box.x1 / elementWidth, 3),
                y: round(this.box.y1 / elementHeight, 3),
                width: round(this.box.width() / elementWidth, 3),
                height: round(this.box.height() / elementHeight, 3),
            };
        }
        else if (mode == 'raw') {
            return {
                x: Math.round(this.box.x1),
                y: Math.round(this.box.y1),
                width: Math.round(this.box.width()),
                height: Math.round(this.box.height()),
            };
        }
    }
    /**
     * Parse user options and set default values.
     */
    static parseOptions(opts) {
        const defaults = {
            aspectRatio: null,
            maxSize: { width: null, height: null },
            minSize: { width: null, height: null },
            startSize: { width: 100, height: 100, unit: '%' },
            returnMode: 'real',
            onInitialize: null,
            onCropStart: null,
            onCropMove: null,
            onCropEnd: null,
        };
        // Parse aspect ratio
        let aspectRatio = null;
        if (opts.aspectRatio !== undefined) {
            if (typeof opts.aspectRatio === 'number') {
                aspectRatio = opts.aspectRatio;
            }
            else if (opts.aspectRatio instanceof Array) {
                aspectRatio = opts.aspectRatio[1] / opts.aspectRatio[0];
            }
        }
        // Parse max width/height
        let maxSize = null;
        if (opts.maxSize !== undefined && opts.maxSize !== null) {
            maxSize = {
                width: opts.maxSize[0] || null,
                height: opts.maxSize[1] || null,
                unit: opts.maxSize[2] || 'px',
            };
        }
        // Parse min width/height
        let minSize = null;
        if (opts.minSize !== undefined && opts.minSize !== null) {
            minSize = {
                width: opts.minSize[0] || null,
                height: opts.minSize[1] || null,
                unit: opts.minSize[2] || 'px',
            };
        }
        // Parse start size
        let startSize = null;
        if (opts.startSize !== undefined && opts.startSize !== null) {
            startSize = {
                width: opts.startSize[0] || null,
                height: opts.startSize[1] || null,
                unit: opts.startSize[2] || '%',
            };
        }
        // Parse callbacks
        let onInitialize = null;
        if (typeof opts.onInitialize === 'function') {
            onInitialize = opts.onInitialize;
        }
        let onCropStart = null;
        if (typeof opts.onCropStart === 'function') {
            onCropStart = opts.onCropStart;
        }
        let onCropEnd = null;
        if (typeof opts.onCropEnd === 'function') {
            onCropEnd = opts.onCropEnd;
        }
        let onCropMove = null;
        if (typeof opts.onUpdate === 'function') {
            // DEPRECATED: onUpdate is deprecated to create a more uniform
            // callback API, such as: onCropStart, onCropMove, onCropEnd
            console.warn('Croppr.js: `onUpdate` is deprecated and will be removed in the next major release. Please use `onCropMove` or `onCropEnd` instead.');
            onCropMove = opts.onUpdate;
        }
        if (typeof opts.onCropMove === 'function') {
            onCropMove = opts.onCropMove;
        }
        // Parse returnMode value
        let returnMode = null;
        if (opts.returnMode !== undefined) {
            const s = opts.returnMode.toLowerCase();
            if (['real', 'ratio', 'raw'].indexOf(s) === -1) {
                throw 'Invalid return mode.';
            }
            returnMode = s;
        }
        // Create function to convert % values to pixels
        const convertToPixels = function (container) {
            const width = container.offsetWidth;
            const height = container.offsetHeight;
            // Convert sizes
            const sizeKeys = ['maxSize', 'minSize', 'startSize'];
            for (let i = 0; i < sizeKeys.length; i++) {
                const key = sizeKeys[i];
                if (this[key] !== null) {
                    if (this[key].unit == '%') {
                        if (this[key].width !== null) {
                            this[key].width = (this[key].width / 100) * width;
                        }
                        if (this[key].height !== null) {
                            this[key].height = (this[key].height / 100) * height;
                        }
                    }
                    delete this[key].unit;
                }
            }
        };
        const defaultValue = (v, d) => (v !== null ? v : d);
        return {
            aspectRatio: defaultValue(aspectRatio, defaults.aspectRatio),
            maxSize: defaultValue(maxSize, defaults.maxSize),
            minSize: defaultValue(minSize, defaults.minSize),
            startSize: defaultValue(startSize, defaults.startSize),
            returnMode: defaultValue(returnMode, defaults.returnMode),
            onInitialize: defaultValue(onInitialize, defaults.onInitialize),
            onCropStart: defaultValue(onCropStart, defaults.onCropStart),
            onCropMove: defaultValue(onCropMove, defaults.onCropMove),
            onCropEnd: defaultValue(onCropEnd, defaults.onCropEnd),
            convertToPixels: convertToPixels,
        };
    }
}
/**
 * HELPER FUNCTIONS
 */
function round(value, decimals) {
    return Number(Math.round((value + 'e' + decimals)) + 'e-' + decimals);
}

/**
 * Croppr.js
 * https://github.com/jamesssooi/Croppr.js
 *
 * A JavaScript image cropper that's lightweight, awesome, and has
 * zero dependencies.
 *
 * (C) 2017 James Ooi. Released under the MIT License.
 */
/**
 * This class is a wrapper for CropprCore that merely implements the main
 * interfaces for the Croppr instance. Look into CropprCore for all the
 * main logic.
 */
class Croppr extends CropprCore {
    /**
     * @constructor
     * Calls the CropprCore's constructor.
     */
    constructor(element, options, _deferred = false) {
        super(element, options, _deferred);
    }
    /**
     * Gets the value of the crop region.
     * @param {String} [mode] Which mode of calculation to use: 'real', 'ratio' or
     *      'raw'.
     */
    getValue(mode) {
        return super.getValue(mode);
    }
    /**
     * Changes the image src.
     * @param {String} src
     */
    setImage(src) {
        return super.setImage(src);
    }
    /**
     * Destroys the Croppr instance
     */
    destroy() {
        return super.destroy();
    }
    /**
     * Moves the crop region to a specified coordinate.
     * @param {Number} x
     * @param {Number} y
     */
    moveTo(x, y) {
        this.box.move(x, y);
        this.redraw();
        // Call the callback
        if (this.options.onCropEnd !== null) {
            this.options.onCropEnd(this.getValue());
        }
        return this;
    }
    /**
     * Resizes the crop region to a specified width and height.
     * @param {Number} width
     * @param {Number} height
     * @param {Array} origin The origin point to resize from.
     *      Defaults to [0.5, 0.5] (center).
     */
    resizeTo(width, height, origin = [0.5, 0.5]) {
        this.box.resize(width, height, origin);
        //////////////////////////////////////////////////////////////////
        const parentWidth = this.cropperEl.offsetWidth;
        const parentHeight = this.cropperEl.offsetHeight;
        this.box.constrainToBoundary(parentWidth, parentHeight, [0.5, 0.5]);
        ///////////////////////////////////////////////////////////////////
        this.redraw();
        // Call the callback
        if (this.options.onCropEnd !== null) {
            this.options.onCropEnd(this.getValue());
        }
        return this;
    }
    /**
     * Scale the crop region by a factor.
     * @param {Number} factor
     * @param {Array} origin The origin point to resize from.
     *      Defaults to [0.5, 0.5] (center).
     */
    scaleBy(factor, origin = [0.5, 0.5]) {
        this.box.scale(factor, origin);
        this.redraw();
        // Call the callback
        if (this.options.onCropEnd !== null) {
            this.options.onCropEnd(this.getValue());
        }
        return this;
    }
    /**
     * Resets the crop region to the initial settings.
     */
    reset(newOptions) {
        if (newOptions) {
            this.options = Object.assign(Object.assign({}, this.options), { newOptions });
        }
        this.box = this.initializeBox(this.options);
        // console.log('🚀 ~ file: croppr.ts ~ line 110 ~ Croppr ~ reset ~ this.box', this.box);
        this.redraw();
        // Call the callback
        if (this.options.onCropEnd !== null) {
            this.options.onCropEnd(this.getValue());
        }
        return this;
    }
    enableVisibility(state) {
        let croppContainer = document.querySelector(".croppr-container");
        if (!croppContainer)
            throw new Error("THere is not any croppr");
        if (state) {
            croppContainer.style.display = "block";
        }
        else {
            croppContainer.style.display = "none";
        }
    }
}

class CropperWrapperComponent {
    constructor() {
        this.imageSrc = '';
        this.croppr = null;
        this.croppSize = { width: 150, height: 150 };
        this.croppUpdate = new EventEmitter();
    }
    onKeyDown() {
        if (!this.croppr)
            return;
        this.croppr.options.aspectRatio = 1.0;
    }
    onKeyUp() {
        if (!this.croppr)
            return;
        this.croppr.options.aspectRatio = null;
    }
    set _imageSrc(value) {
        this.imageSrc = value;
    }
    set setSize(value) {
        this.croppSize = value;
        if (this.croppr)
            this.croppr.resizeTo(this.croppSize.width, this.croppSize.height);
    }
    ngOnInit() { }
    ngAfterViewInit() {
        this.croppr = new Croppr('#croppr', {
            minSize: [32, 32, 'px'],
            startSize: [this.croppSize.width, this.croppSize.height, 'px'],
            onInitialize: (data) => {
                this.croppUpdate.emit(data.getValue());
            },
            onCropEnd: (data) => {
                this.croppUpdate.emit(data);
            },
        });
    }
    ngOnDestroy() {
        if (!this.croppr)
            return;
        this.croppr.destroy();
    }
}
CropperWrapperComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: CropperWrapperComponent, deps: [], target: i0.ɵɵFactoryTarget.Component });
CropperWrapperComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: CropperWrapperComponent, selector: "lib-cropper-wrapper", inputs: { _imageSrc: "_imageSrc", setSize: "setSize" }, outputs: { croppUpdate: "croppUpdate" }, host: { listeners: { "document:keydown.Control": "onKeyDown($event)", "document:keyup.Control": "onKeyUp($event)" } }, ngImport: i0, template: "<img id=\"image-full\" [src]=\"this.imageSrc\" id=\"croppr\" />\n", styles: [""] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: CropperWrapperComponent, decorators: [{
            type: Component,
            args: [{ selector: 'lib-cropper-wrapper', template: "<img id=\"image-full\" [src]=\"this.imageSrc\" id=\"croppr\" />\n" }]
        }], ctorParameters: function () { return []; }, propDecorators: { onKeyDown: [{
                type: HostListener,
                args: ['document:keydown.Control', ['$event']]
            }], onKeyUp: [{
                type: HostListener,
                args: ['document:keyup.Control', ['$event']]
            }], _imageSrc: [{
                type: Input
            }], setSize: [{
                type: Input
            }], croppUpdate: [{
                type: Output
            }] } });

// const Croppr = require('../../services/croppr-service')
class EditImageComponent {
    constructor(chRef) {
        this.chRef = chRef;
        this.imageSrc = '';
        this.color = '';
        this.controlPanelIndex = 0;
        this.showCrop = false;
        this.observer = null;
        this.allFormats = ['webp', 'jpeg', 'png'];
        this.initialState = {};
        this.state = {
            quality: 92,
            maxHeight: 1000,
            maxWidth: 1000,
            cropHeight: 150,
            cropWidth: 150,
            maintainAspectRatio: true,
            format: 'jpeg',
            arrayCopiedImages: [],
            originImageSrc: '',
        };
        this.croppSize = { width: 150, height: 150 };
        this.isMobile = false;
        this.closeModal = new EventEmitter();
    }
    ngOnInit() {
        this.state = JSON.parse(JSON.stringify(Object.assign(Object.assign({}, this.state), this.initialState)));
        // console.log(this.state);
        this.isMobile = window.innerWidth < 800;
        console.log('🚀 ~ file: edit-image.component.ts ~ line 45 ~ EditImageComponent ~ ngOnInit ~ this.isMobile', this.isMobile);
    }
    onCloseEditPanel(saveChanges = false) {
        if (this.observer instanceof ResizeObserver) {
            let imageCroperElRef = document.getElementById('image-croper');
            let imageFullElRef = document.getElementById('image-full');
            this.observer.unobserve(imageCroperElRef);
            this.observer.unobserve(imageFullElRef);
        }
        this.showCrop = false;
        if (saveChanges)
            this.closeModal.next({ state: this.state, imageSrc: this.imageSrc });
        else
            this.closeModal.next(null);
    }
    onControlPanelIndexChange(idex) {
        this.controlPanelIndex = idex;
    }
    calculateSize() {
        if (this.imageSrc && this.imageSrc.length) {
            return Math.ceil(((3 / 4) * this.imageSrc.length) / 1024);
        }
        else {
            return "";
        }
    }
    onChangeSize(changeHeight = false) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.imageSrc = yield convertImageUsingCanvas(this.state.originImageSrc, changeHeight, this.state);
                this.chRef.markForCheck();
            }
            catch (error) {
                console.log('🚀 ~ file: edit-image.component.ts ~ line 76 ~ EditImageComponent ~ onChangeSize ~ error', error);
                this.chRef.markForCheck();
            }
        });
    }
    onChangeQuality() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.imageSrc = yield convertImageUsingCanvas(this.state.originImageSrc, false, this.state);
                this.chRef.markForCheck();
            }
            catch (error) {
                console.log('🚀 ~ file: edit-image.component.ts ~ line 86 ~ EditImageComponent ~ onChangeQuality ~ error', error);
                this.chRef.markForCheck();
            }
        });
    }
    onChangeFormat() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                this.imageSrc = yield convertImageUsingCanvas(this.state.originImageSrc, false, this.state);
                this.chRef.markForCheck();
            }
            catch (error) {
                console.log('🚀 ~ file: edit-image.component.ts ~ line 98 ~ EditImageComponent ~ onChangeFormat ~ error', error);
                this.chRef.markForCheck();
            }
        });
    }
    onRestore() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (this.state.arrayCopiedImages.length > 1) {
                    this.state.arrayCopiedImages.pop();
                    let newValue = this.state.arrayCopiedImages[this.state.arrayCopiedImages.length - 1];
                    this.state = Object.assign(Object.assign({}, this.state), { maxHeight: newValue.height, maxWidth: newValue.width, quality: newValue.quality, format: newValue.format, originImageSrc: newValue.originImageSrc, basicFilters: newValue.basicFilters });
                    this.imageSrc = newValue.lastImage;
                    this.chRef.markForCheck();
                }
            }
            catch (e) {
                console.log('🚀 ~ file: edit-image.component.ts ~ line 126 ~ EditImageComponent ~ onRestore ~ e', e);
            }
        });
    }
    onCroppUpdate(data) {
        this.croppState = data;
        this.state.cropHeight = data.height;
        this.state.cropWidth = data.width;
    }
    onChangeCrop() {
        this.croppSize = { width: this.state.cropWidth, height: this.state.cropHeight };
    }
    onCrop() {
        // const dataHolderRect = document.querySelector('.croppr-container').getBoundingClientRect();
        const canvas = document.createElement('canvas');
        return new Promise((resolve, reject) => {
            let ctx = canvas.getContext('2d');
            let image = new Image();
            image.src = this.imageSrc;
            image.onload = () => {
                var _a, _b, _c, _d, _e, _f, _g, _h;
                // let ratio = image.height / dataHolderRect.height;
                let newWidth = (_a = this.croppState) === null || _a === void 0 ? void 0 : _a.width;
                let newHeight = (_b = this.croppState) === null || _b === void 0 ? void 0 : _b.height;
                canvas.height = newHeight;
                canvas.width = newWidth;
                ctx.drawImage(image, Math.abs(((_c = this.croppState) === null || _c === void 0 ? void 0 : _c.x) || 0), Math.abs(((_d = this.croppState) === null || _d === void 0 ? void 0 : _d.y) || 0), ((_e = this.croppState) === null || _e === void 0 ? void 0 : _e.width) || 0, ((_f = this.croppState) === null || _f === void 0 ? void 0 : _f.height) || 0, 0, 0, ((_g = this.croppState) === null || _g === void 0 ? void 0 : _g.width) || 0, ((_h = this.croppState) === null || _h === void 0 ? void 0 : _h.height) || 0);
                return resolve(canvas.toDataURL(`image/${this.state.format}`, this.state.quality));
            };
            image.onerror = (e) => {
                reject(e);
            };
        })
            .then((dataUri) => {
            this.imageSrc = dataUri;
            this.showCrop = false;
            this.state.maxWidth = canvas.width;
            this.state.maxHeight = canvas.height;
            this.state.originImageSrc = dataUri;
            this.state.cropHeight = 150;
            this.state.cropWidth = 150;
            saveState(this.state, dataUri);
            this.croppSize = { width: 150, height: 150 };
            this.chRef.markForCheck();
        })
            .catch((e) => {
            console.log(e);
        });
    }
    onChangeFilters(data) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (!this.state.basicFilters) {
                    this.state.basicFilters = data;
                }
                else {
                    this.state.basicFilters = Object.assign(Object.assign({}, this.state.basicFilters), data);
                }
                this.imageSrc = yield convertImageUsingCanvas(this.state.originImageSrc, false, this.state);
                this.chRef.markForCheck();
            }
            catch (e) {
                console.log('🚀 ~ file: edit-image.component.ts ~ line 250 ~ EditImageComponent ~ onChangeFilters ~ e', e);
            }
        });
    }
}
EditImageComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: EditImageComponent, deps: [{ token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
EditImageComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: EditImageComponent, selector: "lib-edit-image", inputs: { labels: "labels", imageSrc: "imageSrc", color: "color", initialState: "initialState" }, outputs: { closeModal: "closeModal" }, ngImport: i0, template: "<div id=\"popup\" class=\"popup\">\n  <div\n    style=\"\n      flex-direction: row;\n      box-sizing: border-box;\n      display: flex;\n      place-content: center flex-end;\n      align-items: center;\n      padding: 0px 16px;\n    \"\n  >\n    <button class=\"icon-btn\" (click)=\"onCloseEditPanel(false)\">\n      <span class=\"material-icons\">clear</span>\n    </button>\n  </div>\n\n  <div class=\"image-container\">\n    <div class=\"image-holder-full\">\n      <img id=\"image-full\" [src]=\"this.imageSrc\" [style.display]=\"showCrop ? 'none' : ''\" />\n\n      <lib-cropper-wrapper\n        [setSize]=\"this.croppSize\"\n        (croppUpdate)=\"onCroppUpdate($event)\"\n        [_imageSrc]=\"this.imageSrc\"\n        *ngIf=\"showCrop\"\n      ></lib-cropper-wrapper>\n    </div>\n\n    <div class=\"control-panel\">\n      <lib-tabs [color]=\"this.color\" [_labels]=\"['Basic', 'Filters']\" (indexActivatedChange)=\"onControlPanelIndexChange($event)\">\n        <ng-container *ngIf=\"controlPanelIndex == 0\">\n          <ng-container *ngIf=\"!isMobile || (isMobile && !showCrop)\">\n            <div style=\"display: flex; width: 100%; justify-content: space-between\">\n              <p class=\"item-panel\">{{ labels['Quality'] }}</p>\n              <p class=\"item-panel\">{{ this.state.quality + '%' }}</p>\n            </div>\n\n            <div style=\"flex-direction: row; box-sizing: border-box; display: flex; place-content: flex-start; align-items: flex-start\">\n              <input\n                [readonly]=\"showCrop\"\n                [disabled]=\"showCrop\"\n                class=\"input-range\"\n                (change)=\"onChangeQuality()\"\n                [ngStyle]=\"{ maxWidth: '100%', width: '100%', color: color }\"\n                [(ngModel)]=\"this.state.quality\"\n                type=\"range\"\n                min=\"1\"\n                max=\"100\"\n                value=\"50\"\n              />\n            </div>\n\n            <div class=\"item-panel\" style=\"display: flex; width: 100%; justify-content: space-between\">\n              {{ labels['Max dimensions'] }}\n              <div style=\"display: flex; align-items: center\">\n                <input\n                  [readonly]=\"showCrop\"\n                  [disabled]=\"showCrop\"\n                  type=\"checkbox\"\n                  [(ngModel)]=\"this.state.maintainAspectRatio\"\n                  [style.color]=\"color\"\n                />\n                <span class=\"caption\">{{ labels['aspect-ratio'] }}</span>\n              </div>\n            </div>\n\n            <div\n              style=\"\n                margin-top: 8px !important;\n                flex-flow: row wrap;\n                box-sizing: border-box;\n                display: flex;\n                place-content: flex-start space-between;\n                align-items: flex-start;\n              \"\n            >\n              <div class=\"form-field\" style=\"max-width: 48%; width: 48%\">\n                <label>{{ labels['max-width(px)'] }}</label>\n                <input\n                  [readonly]=\"showCrop\"\n                  [disabled]=\"showCrop\"\n                  (change)=\"onChangeSize(false)\"\n                  placeholder=\"{{ labels['max-width(px)'] }}\"\n                  [(ngModel)]=\"this.state.maxWidth\"\n                  type=\"number\"\n                  [min]=\"0\"\n                  [max]=\"2000\"\n                />\n              </div>\n\n              <div class=\"form-field\" style=\"max-width: 48%; width: 48%\">\n                <label>{{ labels['max-height(px)'] }}</label>\n                <input\n                  [readonly]=\"showCrop\"\n                  [disabled]=\"showCrop\"\n                  (change)=\"onChangeSize(true)\"\n                  placeholder=\"{{ labels['max-height(px)'] }}\"\n                  [(ngModel)]=\"this.state.maxHeight\"\n                  type=\"number\"\n                  [min]=\"0\"\n                  [max]=\"2000\"\n                />\n              </div>\n            </div>\n\n            <p class=\"item-panel\">{{ labels['Format'] }}</p>\n            <div\n              style=\"\n                margin-top: 8px !important;\n                flex-direction: row;\n                box-sizing: border-box;\n                display: flex;\n                place-content: flex-start;\n                align-items: flex-start;\n              \"\n            >\n              <div class=\"form-field\" style=\"width: 100%\">\n                <select [disabled]=\"showCrop\" [(ngModel)]=\"this.state.format\" (change)=\"onChangeFormat()\">\n                  <option *ngFor=\"let formatItem of allFormats\" [value]=\"formatItem\">{{ formatItem }}</option>\n                </select>\n              </div>\n            </div>\n          </ng-container>\n          <!-- <p class=\"item-panel\">{{ labels['Rotate'] }}</p>\n\n          <div\n            style=\"\n              margin-top: 8px !important;\n              flex-direction: row;\n              box-sizing: border-box;\n              display: flex;\n              place-content: flex-start;\n              align-items: flex-start;\n            \"\n          >\n            <button [disabled]=\"showCrop\" class=\"icon-btn\" style=\"padding-left: 0px\" (click)=\"onRotate(90)\">\n              <span class=\"material-icons\"> rotate_left </span>\n            </button>\n            <button [disabled]=\"showCrop\" class=\"icon-btn\" (click)=\"onRestore()\" (click)=\"onRotate(-90)\">\n              <span class=\"material-icons\"> rotate_right </span>\n            </button>\n          </div>\n\n          <hr />\n          <br /> -->\n\n          <div style=\"display: flex; justify-content: space-between; margin-bottom: 8px\">\n            <span style=\"display: flex; align-items: center\">\n              <input type=\"checkbox\" [(ngModel)]=\"showCrop\" [style.color]=\"color\" style=\"margin-bottom: 3px\" />\n              <span class=\"item-panel\" style=\"margin-left: 4px\">{{ labels['Crop'] }}</span>\n            </span>\n          </div>\n\n          <ng-container *ngIf=\"showCrop\">\n            <div\n              style=\"\n                margin-top: 8px !important;\n                flex-flow: row wrap;\n                box-sizing: border-box;\n                display: flex;\n                place-content: flex-start space-between;\n                align-items: flex-start;\n              \"\n            >\n              <div class=\"form-field\" style=\"max-width: 48%; width: 48%; margin-bottom: 8px\">\n                <label>{{ labels['width(px)'] }}</label>\n                <input\n                  (change)=\"onChangeCrop()\"\n                  placeholder=\"{{ labels['width(px)'] }}\"\n                  [(ngModel)]=\"state.cropWidth\"\n                  type=\"number\"\n                  [min]=\"0\"\n                  [max]=\"2000\"\n                />\n              </div>\n              <div class=\"form-field\" style=\"max-width: 48%; width: 48%; margin-bottom: 8px\">\n                <label>{{ labels['height(px)'] }}</label>\n                <input\n                  (change)=\"onChangeCrop()\"\n                  placeholder=\"{{ labels['height(px)'] }}\"\n                  [(ngModel)]=\"state.cropHeight\"\n                  type=\"number\"\n                  [min]=\"0\"\n                  [max]=\"2000\"\n                />\n              </div>\n            </div>\n\n            <p style=\"margin-bottom: 4px !important\">\n              <button title=\"Cut the image\" class=\"icon-btn\" (click)=\"onCrop()\">\n                <span class=\"material-icons\"> crop </span>\n              </button>\n            </p>\n          </ng-container>\n        </ng-container>\n        <ng-container *ngIf=\"controlPanelIndex == 1\">\n          <lib-basic-filters\n            [filterState]=\"this.state.basicFilters\"\n            (changeFilter)=\"onChangeFilters($event)\"\n            [labels]=\"this.labels\"\n            [color]=\"this.color\"\n          ></lib-basic-filters>\n        </ng-container>\n      </lib-tabs>\n\n      <button\n        title=\"{{ labels['Undo'] }}\"\n        [disabled]=\"this.state.arrayCopiedImages.length <= 1\"\n        style=\"position: absolute; right: 10px; top: 30px\"\n        class=\"icon-btn\"\n        (click)=\"onRestore()\"\n      >\n        <span class=\"material-icons\"> refresh </span>\n      </button>\n      <div\n        style=\"\n          flex-direction: row;\n          box-sizing: border-box;\n          display: flex;\n          place-content: center space-between;\n          align-items: center;\n          margin-top: 8px;\n        \"\n      >\n        <button class=\"save-btn\" (click)=\"onCloseEditPanel(true)\">{{ labels['Save'] }}</button>\n\n        <p\n          *ngIf=\"this.calculateSize()\"\n          class=\"caption image-caption\"\n          [ngStyle]=\"{\n            color: this.calculateSize() > 120 ? '#f44336' : 'unset',\n            fontWeight: this.calculateSize() > 120 ? '500' : 'unset'\n          }\"\n        >\n          size: {{ this.calculateSize() }}Kb &nbsp; {{ this.state.format }}\n        </p>\n      </div>\n    </div>\n  </div>\n</div>\n", styles: [".popup{width:100vw;max-height:100%;height:100%;overflow:auto;position:fixed;top:0;left:0;background-color:#000c;z-index:1000;padding:24px 16px;color:#fff;box-sizing:border-box;animation-name:show;animation-duration:.4s}.popup .image-container{margin-top:50px;margin-bottom:50px;width:100%;flex-flow:row wrap;box-sizing:border-box;display:flex;place-content:flex-start center;align-items:flex-start}.popup .image-container .image-holder-full{height:auto;width:auto;position:relative;display:contents}.popup .material-icons{color:#fff}.popup img{vertical-align:middle;max-height:650px;max-width:100%;object-fit:cover;object-position:center}@media (max-width: 1024px){.popup{background-color:#000000d9;padding:8px}.popup img{max-height:100%;max-width:100%}}@media (max-width: 599px){.popup img{margin:0}}.popup .control-panel{color:#fff;background-color:#000000eb;margin:0 16px;padding:16px;width:18rem;border-radius:8px;flex-direction:column;box-sizing:border-box;display:flex;place-content:stretch flex-start;align-items:stretch;max-width:100%;position:relative}@media (max-width: 599px){.popup .control-panel{margin:8px 0;width:100%}}.popup .control-panel .title-panel{padding:0 4px;font-size:17px;font-weight:500;margin-bottom:16px!important}.popup .control-panel .item-panel{padding:0;font-size:14px;font-weight:500}.image-croper{position:absolute;width:180px;height:180px;min-height:64px;min-width:64px;border:2.5px solid #fafafa;box-sizing:border-box;resize:both;overflow:auto;opacity:0;border-radius:4px;overflow:hidden;z-index:10}.image-croper #image-croper-header{padding:0;cursor:move;z-index:9;background-color:transparent;color:#fff;height:100%;display:grid;gap:0px;grid-template-columns:repeat(3,1fr);width:100%;box-sizing:border-box;position:absolute;top:50%;transform:translateY(-50%);opacity:.8}.image-croper #image-croper-header .material-icons{color:#fff}.input-range{margin-bottom:16px;margin-top:4px}input[type=checkbox]{cursor:pointer}.form-field{margin-bottom:16px}.form-field label{font-size:12px;opacity:.92;margin-bottom:4px;display:block}.form-field input{height:34px;width:100%;box-sizing:border-box;border-radius:4px;border:none;padding:2px 8px;outline:none}.form-field select{height:34px;width:100%;box-sizing:border-box;border-radius:4px;border:none;padding:2px 8px;outline:none;background-color:#fff}.save-btn{padding:0 8px;height:34px;box-sizing:border-box;background-color:#fff;color:#000;border:none;border-radius:4px;cursor:pointer}.save-btn:active{transform:scale(.95)}\n"], dependencies: [{ kind: "directive", type: i1.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "directive", type: i2.NgSelectOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2.ɵNgSelectMultipleOption, selector: "option", inputs: ["ngValue", "value"] }, { kind: "directive", type: i2.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i2.NumberValueAccessor, selector: "input[type=number][formControlName],input[type=number][formControl],input[type=number][ngModel]" }, { kind: "directive", type: i2.RangeValueAccessor, selector: "input[type=range][formControlName],input[type=range][formControl],input[type=range][ngModel]" }, { kind: "directive", type: i2.CheckboxControlValueAccessor, selector: "input[type=checkbox][formControlName],input[type=checkbox][formControl],input[type=checkbox][ngModel]" }, { kind: "directive", type: i2.SelectControlValueAccessor, selector: "select:not([multiple])[formControlName],select:not([multiple])[formControl],select:not([multiple])[ngModel]", inputs: ["compareWith"] }, { kind: "directive", type: i2.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i2.MinValidator, selector: "input[type=number][min][formControlName],input[type=number][min][formControl],input[type=number][min][ngModel]", inputs: ["min"] }, { kind: "directive", type: i2.MaxValidator, selector: "input[type=number][max][formControlName],input[type=number][max][formControl],input[type=number][max][ngModel]", inputs: ["max"] }, { kind: "directive", type: i2.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "component", type: TabsComponent, selector: "lib-tabs", inputs: ["color", "_labels", "_indexActivated"], outputs: ["indexActivatedChange"] }, { kind: "component", type: BasicFiltersComponent, selector: "lib-basic-filters", inputs: ["color", "labels", "filterState"], outputs: ["changeFilter"] }, { kind: "component", type: CropperWrapperComponent, selector: "lib-cropper-wrapper", inputs: ["_imageSrc", "setSize"], outputs: ["croppUpdate"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: EditImageComponent, decorators: [{
            type: Component,
            args: [{ selector: 'lib-edit-image', template: "<div id=\"popup\" class=\"popup\">\n  <div\n    style=\"\n      flex-direction: row;\n      box-sizing: border-box;\n      display: flex;\n      place-content: center flex-end;\n      align-items: center;\n      padding: 0px 16px;\n    \"\n  >\n    <button class=\"icon-btn\" (click)=\"onCloseEditPanel(false)\">\n      <span class=\"material-icons\">clear</span>\n    </button>\n  </div>\n\n  <div class=\"image-container\">\n    <div class=\"image-holder-full\">\n      <img id=\"image-full\" [src]=\"this.imageSrc\" [style.display]=\"showCrop ? 'none' : ''\" />\n\n      <lib-cropper-wrapper\n        [setSize]=\"this.croppSize\"\n        (croppUpdate)=\"onCroppUpdate($event)\"\n        [_imageSrc]=\"this.imageSrc\"\n        *ngIf=\"showCrop\"\n      ></lib-cropper-wrapper>\n    </div>\n\n    <div class=\"control-panel\">\n      <lib-tabs [color]=\"this.color\" [_labels]=\"['Basic', 'Filters']\" (indexActivatedChange)=\"onControlPanelIndexChange($event)\">\n        <ng-container *ngIf=\"controlPanelIndex == 0\">\n          <ng-container *ngIf=\"!isMobile || (isMobile && !showCrop)\">\n            <div style=\"display: flex; width: 100%; justify-content: space-between\">\n              <p class=\"item-panel\">{{ labels['Quality'] }}</p>\n              <p class=\"item-panel\">{{ this.state.quality + '%' }}</p>\n            </div>\n\n            <div style=\"flex-direction: row; box-sizing: border-box; display: flex; place-content: flex-start; align-items: flex-start\">\n              <input\n                [readonly]=\"showCrop\"\n                [disabled]=\"showCrop\"\n                class=\"input-range\"\n                (change)=\"onChangeQuality()\"\n                [ngStyle]=\"{ maxWidth: '100%', width: '100%', color: color }\"\n                [(ngModel)]=\"this.state.quality\"\n                type=\"range\"\n                min=\"1\"\n                max=\"100\"\n                value=\"50\"\n              />\n            </div>\n\n            <div class=\"item-panel\" style=\"display: flex; width: 100%; justify-content: space-between\">\n              {{ labels['Max dimensions'] }}\n              <div style=\"display: flex; align-items: center\">\n                <input\n                  [readonly]=\"showCrop\"\n                  [disabled]=\"showCrop\"\n                  type=\"checkbox\"\n                  [(ngModel)]=\"this.state.maintainAspectRatio\"\n                  [style.color]=\"color\"\n                />\n                <span class=\"caption\">{{ labels['aspect-ratio'] }}</span>\n              </div>\n            </div>\n\n            <div\n              style=\"\n                margin-top: 8px !important;\n                flex-flow: row wrap;\n                box-sizing: border-box;\n                display: flex;\n                place-content: flex-start space-between;\n                align-items: flex-start;\n              \"\n            >\n              <div class=\"form-field\" style=\"max-width: 48%; width: 48%\">\n                <label>{{ labels['max-width(px)'] }}</label>\n                <input\n                  [readonly]=\"showCrop\"\n                  [disabled]=\"showCrop\"\n                  (change)=\"onChangeSize(false)\"\n                  placeholder=\"{{ labels['max-width(px)'] }}\"\n                  [(ngModel)]=\"this.state.maxWidth\"\n                  type=\"number\"\n                  [min]=\"0\"\n                  [max]=\"2000\"\n                />\n              </div>\n\n              <div class=\"form-field\" style=\"max-width: 48%; width: 48%\">\n                <label>{{ labels['max-height(px)'] }}</label>\n                <input\n                  [readonly]=\"showCrop\"\n                  [disabled]=\"showCrop\"\n                  (change)=\"onChangeSize(true)\"\n                  placeholder=\"{{ labels['max-height(px)'] }}\"\n                  [(ngModel)]=\"this.state.maxHeight\"\n                  type=\"number\"\n                  [min]=\"0\"\n                  [max]=\"2000\"\n                />\n              </div>\n            </div>\n\n            <p class=\"item-panel\">{{ labels['Format'] }}</p>\n            <div\n              style=\"\n                margin-top: 8px !important;\n                flex-direction: row;\n                box-sizing: border-box;\n                display: flex;\n                place-content: flex-start;\n                align-items: flex-start;\n              \"\n            >\n              <div class=\"form-field\" style=\"width: 100%\">\n                <select [disabled]=\"showCrop\" [(ngModel)]=\"this.state.format\" (change)=\"onChangeFormat()\">\n                  <option *ngFor=\"let formatItem of allFormats\" [value]=\"formatItem\">{{ formatItem }}</option>\n                </select>\n              </div>\n            </div>\n          </ng-container>\n          <!-- <p class=\"item-panel\">{{ labels['Rotate'] }}</p>\n\n          <div\n            style=\"\n              margin-top: 8px !important;\n              flex-direction: row;\n              box-sizing: border-box;\n              display: flex;\n              place-content: flex-start;\n              align-items: flex-start;\n            \"\n          >\n            <button [disabled]=\"showCrop\" class=\"icon-btn\" style=\"padding-left: 0px\" (click)=\"onRotate(90)\">\n              <span class=\"material-icons\"> rotate_left </span>\n            </button>\n            <button [disabled]=\"showCrop\" class=\"icon-btn\" (click)=\"onRestore()\" (click)=\"onRotate(-90)\">\n              <span class=\"material-icons\"> rotate_right </span>\n            </button>\n          </div>\n\n          <hr />\n          <br /> -->\n\n          <div style=\"display: flex; justify-content: space-between; margin-bottom: 8px\">\n            <span style=\"display: flex; align-items: center\">\n              <input type=\"checkbox\" [(ngModel)]=\"showCrop\" [style.color]=\"color\" style=\"margin-bottom: 3px\" />\n              <span class=\"item-panel\" style=\"margin-left: 4px\">{{ labels['Crop'] }}</span>\n            </span>\n          </div>\n\n          <ng-container *ngIf=\"showCrop\">\n            <div\n              style=\"\n                margin-top: 8px !important;\n                flex-flow: row wrap;\n                box-sizing: border-box;\n                display: flex;\n                place-content: flex-start space-between;\n                align-items: flex-start;\n              \"\n            >\n              <div class=\"form-field\" style=\"max-width: 48%; width: 48%; margin-bottom: 8px\">\n                <label>{{ labels['width(px)'] }}</label>\n                <input\n                  (change)=\"onChangeCrop()\"\n                  placeholder=\"{{ labels['width(px)'] }}\"\n                  [(ngModel)]=\"state.cropWidth\"\n                  type=\"number\"\n                  [min]=\"0\"\n                  [max]=\"2000\"\n                />\n              </div>\n              <div class=\"form-field\" style=\"max-width: 48%; width: 48%; margin-bottom: 8px\">\n                <label>{{ labels['height(px)'] }}</label>\n                <input\n                  (change)=\"onChangeCrop()\"\n                  placeholder=\"{{ labels['height(px)'] }}\"\n                  [(ngModel)]=\"state.cropHeight\"\n                  type=\"number\"\n                  [min]=\"0\"\n                  [max]=\"2000\"\n                />\n              </div>\n            </div>\n\n            <p style=\"margin-bottom: 4px !important\">\n              <button title=\"Cut the image\" class=\"icon-btn\" (click)=\"onCrop()\">\n                <span class=\"material-icons\"> crop </span>\n              </button>\n            </p>\n          </ng-container>\n        </ng-container>\n        <ng-container *ngIf=\"controlPanelIndex == 1\">\n          <lib-basic-filters\n            [filterState]=\"this.state.basicFilters\"\n            (changeFilter)=\"onChangeFilters($event)\"\n            [labels]=\"this.labels\"\n            [color]=\"this.color\"\n          ></lib-basic-filters>\n        </ng-container>\n      </lib-tabs>\n\n      <button\n        title=\"{{ labels['Undo'] }}\"\n        [disabled]=\"this.state.arrayCopiedImages.length <= 1\"\n        style=\"position: absolute; right: 10px; top: 30px\"\n        class=\"icon-btn\"\n        (click)=\"onRestore()\"\n      >\n        <span class=\"material-icons\"> refresh </span>\n      </button>\n      <div\n        style=\"\n          flex-direction: row;\n          box-sizing: border-box;\n          display: flex;\n          place-content: center space-between;\n          align-items: center;\n          margin-top: 8px;\n        \"\n      >\n        <button class=\"save-btn\" (click)=\"onCloseEditPanel(true)\">{{ labels['Save'] }}</button>\n\n        <p\n          *ngIf=\"this.calculateSize()\"\n          class=\"caption image-caption\"\n          [ngStyle]=\"{\n            color: this.calculateSize() > 120 ? '#f44336' : 'unset',\n            fontWeight: this.calculateSize() > 120 ? '500' : 'unset'\n          }\"\n        >\n          size: {{ this.calculateSize() }}Kb &nbsp; {{ this.state.format }}\n        </p>\n      </div>\n    </div>\n  </div>\n</div>\n", styles: [".popup{width:100vw;max-height:100%;height:100%;overflow:auto;position:fixed;top:0;left:0;background-color:#000c;z-index:1000;padding:24px 16px;color:#fff;box-sizing:border-box;animation-name:show;animation-duration:.4s}.popup .image-container{margin-top:50px;margin-bottom:50px;width:100%;flex-flow:row wrap;box-sizing:border-box;display:flex;place-content:flex-start center;align-items:flex-start}.popup .image-container .image-holder-full{height:auto;width:auto;position:relative;display:contents}.popup .material-icons{color:#fff}.popup img{vertical-align:middle;max-height:650px;max-width:100%;object-fit:cover;object-position:center}@media (max-width: 1024px){.popup{background-color:#000000d9;padding:8px}.popup img{max-height:100%;max-width:100%}}@media (max-width: 599px){.popup img{margin:0}}.popup .control-panel{color:#fff;background-color:#000000eb;margin:0 16px;padding:16px;width:18rem;border-radius:8px;flex-direction:column;box-sizing:border-box;display:flex;place-content:stretch flex-start;align-items:stretch;max-width:100%;position:relative}@media (max-width: 599px){.popup .control-panel{margin:8px 0;width:100%}}.popup .control-panel .title-panel{padding:0 4px;font-size:17px;font-weight:500;margin-bottom:16px!important}.popup .control-panel .item-panel{padding:0;font-size:14px;font-weight:500}.image-croper{position:absolute;width:180px;height:180px;min-height:64px;min-width:64px;border:2.5px solid #fafafa;box-sizing:border-box;resize:both;overflow:auto;opacity:0;border-radius:4px;overflow:hidden;z-index:10}.image-croper #image-croper-header{padding:0;cursor:move;z-index:9;background-color:transparent;color:#fff;height:100%;display:grid;gap:0px;grid-template-columns:repeat(3,1fr);width:100%;box-sizing:border-box;position:absolute;top:50%;transform:translateY(-50%);opacity:.8}.image-croper #image-croper-header .material-icons{color:#fff}.input-range{margin-bottom:16px;margin-top:4px}input[type=checkbox]{cursor:pointer}.form-field{margin-bottom:16px}.form-field label{font-size:12px;opacity:.92;margin-bottom:4px;display:block}.form-field input{height:34px;width:100%;box-sizing:border-box;border-radius:4px;border:none;padding:2px 8px;outline:none}.form-field select{height:34px;width:100%;box-sizing:border-box;border-radius:4px;border:none;padding:2px 8px;outline:none;background-color:#fff}.save-btn{padding:0 8px;height:34px;box-sizing:border-box;background-color:#fff;color:#000;border:none;border-radius:4px;cursor:pointer}.save-btn:active{transform:scale(.95)}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }]; }, propDecorators: { labels: [{
                type: Input
            }], imageSrc: [{
                type: Input
            }], color: [{
                type: Input
            }], initialState: [{
                type: Input
            }], closeModal: [{
                type: Output
            }] } });

class NgpImagePickerComponent {
    constructor(chRef) {
        this.chRef = chRef;
        this.config = {
            language: 'en',
            objectFit: 'cover',
            hideDeleteBtn: false,
            hideDownloadBtn: false,
            hideEditBtn: false,
            hideAddBtn: false,
        };
        this.state = {
            quality: 92,
            maxHeight: 1000,
            maxWidth: 1000,
            cropHeight: 150,
            cropWidth: 150,
            maintainAspectRatio: true,
            format: 'jpeg',
            arrayCopiedImages: [],
            originImageSrc: '',
        };
        this.loadImage = false;
        this.fileType = '';
        this.urlImage = '';
        this.uuidFilePicker = Date.now().toString(20);
        this.showEditPanel = false;
        this.imageName = 'donload';
        this.labels = labelEn;
        this.arrayCopiedImages = [];
        this.color = '#1e88e5';
        this.imagePicker = null;
        this.$imageChanged = new EventEmitter();
        this.$imageOriginal = new EventEmitter();
    }
    set _imageSrc(value) {
        if (value) {
            this.parseToBase64(value).then((dataUri) => {
                this.imageSrc = dataUri;
                this.state.originImageSrc = value;
                this.state.arrayCopiedImages.push({
                    lastImage: dataUri,
                    width: this.state.maxWidth,
                    height: this.state.maxHeight,
                    quality: this.state.quality,
                    format: this.state.format,
                    originImageSrc: value,
                });
                this.$imageOriginal.next(this.state.originImageSrc);
                this.loadImage = true;
                this.chRef.markForCheck();
            });
        }
        else {
            this.imageSrc = null;
            this.state.originImageSrc = null;
            this.loadImage = false;
            this.state.arrayCopiedImages = [];
            this.$imageOriginal.next(null);
            this.state = Object.assign(Object.assign({}, this.state), { format: 'jpeg', maxHeight: 1000, maxWidth: 1000, cropHeight: 150, cropWidth: 150, maintainAspectRatio: true });
            this.showEditPanel = false;
            this.chRef.markForCheck();
        }
    }
    set _config(value) {
        this.processConfig(value);
    }
    ngOnInit() {
        this.appendLinkIconsToHead();
    }
    appendLinkIconsToHead() {
        let head = document.head;
        let linkIcons = head.querySelector('#ngp-image-picker-icons-id');
        if (linkIcons)
            return;
        let link = document.createElement('link');
        link.href = 'https://fonts.googleapis.com/icon?family=Material+Icons';
        link.rel = 'stylesheet';
        link.id = 'ngp-image-picker-icons-id';
        head.appendChild(link);
    }
    onUpload(event) {
        var _a;
        event.preventDefault();
        (_a = this.imagePicker) === null || _a === void 0 ? void 0 : _a.nativeElement.click();
    }
    handleFileSelect(evt) {
        var _a;
        const files = (_a = evt.target) === null || _a === void 0 ? void 0 : _a.files;
        if (files) {
            const file = files[0];
            this.imageName = file.name.split('.')[0];
            this.fileType = file.type;
            if (!this.fileType.includes('image'))
                return;
            this.urlImage = `data:${file.type};base64,`;
            if (file) {
                this.state.format = this.fileType.split('image/')[1];
                const reader = new FileReader();
                reader.onload = this.handleReaderLoaded.bind(this);
                reader.readAsBinaryString(file);
            }
        }
    }
    handleReaderLoaded(readerEvt) {
        return __awaiter(this, void 0, void 0, function* () {
            const binaryString = readerEvt.target.result;
            const base64textString = btoa(binaryString);
            this.state.originImageSrc = this.urlImage + base64textString;
            if (this.config.compressInitial) {
                this.state = Object.assign(Object.assign({}, this.state), { quality: Math.min(this.config.compressInitial || 92, 100), maintainAspectRatio: true, format: 'jpeg' });
                this.imageSrc = yield convertImageUsingCanvas(this.urlImage + base64textString, false, this.state, { getDimFromImage: true });
            }
            else {
                this.imageSrc = this.urlImage + base64textString;
                let img = document.createElement('img');
                img.src = this.imageSrc;
                img.onload = () => {
                    this.state.arrayCopiedImages = [];
                    this.state.maxHeight = img.height;
                    this.state.maxWidth = img.width;
                    this.state.arrayCopiedImages.push({
                        lastImage: this.imageSrc,
                        width: img.width,
                        height: img.height,
                        quality: this.state.quality,
                        format: this.state.format,
                        originImageSrc: this.state.originImageSrc,
                    });
                };
            }
            this.$imageChanged.next(this.imageSrc);
            this.loadImage = true;
            this.chRef.markForCheck();
        });
    }
    onOpenEditPanel() {
        this.showEditPanel = true;
    }
    onCloseEditPanel(data) {
        if (data) {
            this.state = data.state;
            this.imageSrc = data.imageSrc;
            this.$imageChanged.next(this.imageSrc);
        }
        this.showEditPanel = false;
    }
    parseToBase64(imageUrl) {
        let types = imageUrl.split('.');
        let type = types[types.length - 1];
        if (type && (type == 'png' || type == 'jpeg' || type == 'webp')) {
            type = type;
        }
        else {
            type = 'jpeg';
        }
        this.state = Object.assign(Object.assign({}, this.state), { format: type });
        return new Promise((resolve, reject) => {
            let img = new Image();
            img.crossOrigin = 'Anonymous';
            this.state = Object.assign(Object.assign({}, this.state), { maxHeight: img.height, maxWidth: img.width });
            img.onload = () => {
                let canvas = document.createElement('canvas');
                let ctx = canvas.getContext('2d');
                if (!ctx)
                    return;
                let ratio = 1.0;
                canvas.width = img.width * ratio;
                canvas.height = img.height * ratio;
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                let dataURI = canvas.toDataURL(`image/${type}`, this.state.quality);
                return resolve({
                    dataUri: dataURI,
                    width: canvas.width,
                    height: canvas.height,
                });
            };
            img.onerror = (e) => {
                return reject(e.message || `Error loading the src = ${imageUrl}`);
            };
            img.src = imageUrl;
        }).then((data) => {
            this.state = Object.assign(Object.assign({}, this.state), { maxHeight: data.height, maxWidth: data.width });
            return data.dataUri;
        });
    }
    processConfig(value) {
        if (value && value.constructor == Object) {
            this.config = Object.assign(Object.assign({}, this.config), value);
            if (value.language != undefined) {
                if (value.language == 'en') {
                    this.labels = Object.assign({}, labelEn);
                }
                if (value.language == 'es') {
                    this.labels = Object.assign({}, labelEs);
                }
                if (value.language == 'fr') {
                    this.labels = Object.assign({}, labelFr);
                }
                if (value.language == 'de') {
                    this.labels = Object.assign({}, labelDe);
                }
            }
        }
    }
    calculateSize() {
        if (this.imageSrc && this.imageSrc.length) {
            return Math.ceil(((3 / 4) * this.imageSrc.length) / 1024);
        }
        else {
            return 0;
        }
    }
    ////////////////////////////////////////////////
    onRemove() {
        this.imageSrc = null;
        this.loadImage = false;
        this.$imageOriginal.next(null);
        this.$imageChanged.next(null);
        this.state = Object.assign(Object.assign({}, this.state), { originImageSrc: '', format: 'jpeg', maxHeight: 1000, maxWidth: 1000, cropHeight: 150, cropWidth: 150, maintainAspectRatio: true, arrayCopiedImages: [], basicFilters: undefined, quality: 92 });
        this.showEditPanel = false;
    }
}
NgpImagePickerComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: NgpImagePickerComponent, deps: [{ token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
NgpImagePickerComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.0.4", type: NgpImagePickerComponent, selector: "ngp-image-picker", inputs: { color: "color", _imageSrc: "_imageSrc", _config: "_config" }, outputs: { $imageChanged: "$imageChanged", $imageOriginal: "$imageOriginal" }, viewQueries: [{ propertyName: "imagePicker", first: true, predicate: ["imagePicker"], descendants: true }], ngImport: i0, template: "<div *ngIf=\"!loadImage\" class=\"place-image\">\n  <div\n    class=\"image-holder\"\n    [ngStyle]=\"{\n      width: this.config.width,\n      height: this.config.height,\n      borderRadius: this.config.borderRadius,\n      aspectRatio: this.config.aspectRatio\n    }\"\n  >\n    <button title=\"{{ labels['Upload a image'] }}\" class=\"icon-btn image-upload-btn\" (click)=\"onUpload($event)\">\n      <!--  <span class=\"material-icons\">add_a_photo</mat-icon> -->\n      <span class=\"material-icons\">add_a_photo</span>\n    </button>\n\n    <input #imagePicker type=\"file\" style=\"display: none\" [id]=\"'filePicker-' + this.uuidFilePicker\" (change)=\"handleFileSelect($event)\" />\n  </div>\n</div>\n<div *ngIf=\"loadImage\" class=\"place-image\">\n  <div\n    class=\"image-holder-loaded\"\n    [ngStyle]=\"{\n      width: this.config.width,\n      height: this.config.height,\n      borderRadius: this.config.borderRadius,\n      aspectRatio: this.config.aspectRatio\n    }\"\n  >\n    <img\n      [src]=\"this.imageSrc\"\n      alt=\"image-loaded\"\n      [ngStyle]=\"{ borderRadius: this.config.borderRadius, objectFit: this.config.objectFit }\"\n    />\n    <input #imagePicker type=\"file\" style=\"display: none\" [id]=\"'filePicker-' + this.uuidFilePicker\" (change)=\"handleFileSelect($event)\" />\n  </div>\n  <p\n    *ngIf=\"this.calculateSize()\"\n    class=\"caption image-caption\"\n    [ngStyle]=\"{\n      color: this.calculateSize() > 120 ? '#f44336' : 'unset',\n      fontWeight: this.calculateSize() > 120 ? '500' : 'unset'\n    }\"\n  >\n    size: {{ this.calculateSize() }}Kb &nbsp; {{ this.state.format }}\n  </p>\n\n  <div\n    style=\"flex-direction: row; box-sizing: border-box; display: flex; place-content: flex-start; align-items: flex-start\"\n    class=\"editing-bar-btn\"\n  >\n    <button\n      class=\"icon-btn\"\n      id=\"upload-img\"\n      *ngIf=\"!this.config.hideAddBtn\"\n      title=\"{{ labels['Upload a image'] }}\"\n      (click)=\"onUpload($event)\"\n    >\n      <span class=\"material-icons\">add_a_photo</span>\n    </button>\n    <button\n      class=\"icon-btn\"\n      id=\"edit-img\"\n      *ngIf=\"!this.config.hideEditBtn\"\n      title=\"{{ labels['Open the editor panel'] }}\"\n      (click)=\"onOpenEditPanel()\"\n    >\n      <span class=\"material-icons\">edit</span>\n    </button>\n    <a\n      id=\"download-img\"\n      *ngIf=\"!this.config.hideDownloadBtn\"\n      title=\"{{ labels['Download the image'] }}\"\n      [href]=\"this.imageSrc\"\n      download=\"{{ imageName }}\"\n    >\n      <span class=\"material-icons\">cloud_download</span>\n    </a>\n    <button class=\"icon-btn\" id=\"delete-img\" *ngIf=\"!this.config.hideDeleteBtn\" title=\"{{ labels['Remove'] }}\" (click)=\"onRemove()\">\n      <span class=\"material-icons\">delete</span>\n    </button>\n  </div>\n</div>\n\n<lib-edit-image\n  *ngIf=\"showEditPanel\"\n  [imageSrc]=\"this.imageSrc\"\n  [initialState]=\"this.state\"\n  [labels]=\"this.labels\"\n  [color]=\"this.color\"\n  (closeModal)=\"this.onCloseEditPanel($event)\"\n></lib-edit-image>\n", styles: ["ngp-image-picker p{margin:0!important;padding:0!important}ngp-image-picker .place-image{flex-direction:column;box-sizing:border-box;display:flex;place-content:flex-start;align-items:flex-start}ngp-image-picker .place-image .image-holder{flex-direction:column;display:flex;place-content:center;align-items:center;position:relative;border-radius:16px;max-width:100%!important;box-sizing:border-box;border:2px rgba(0,0,0,.3) solid;background-color:#fcfcfc}@media (max-width: 599px){ngp-image-picker .place-image .image-holder{max-width:100%!important;max-height:250px!important}}ngp-image-picker .place-image .image-holder .image-upload-btn{transition:all .5s ease;position:relative;opacity:.85;width:50px;height:50px;color:#424242}ngp-image-picker .place-image .image-holder .image-upload-btn .material-icons{font-size:50px;width:50px;height:50px;line-height:50px;color:#424242}@media (max-width: 599px){ngp-image-picker .place-image .image-holder .image-upload-btn{opacity:1;width:30px;height:30px}ngp-image-picker .place-image .image-holder .image-upload-btn .material-icons{font-size:30px;width:30px;height:30px;line-height:30px}}ngp-image-picker .place-image .image-holder:hover .image-upload-btn{opacity:1;transition:all .5s ease}ngp-image-picker .place-image .image-holder-loaded{flex-direction:column;display:flex;place-content:center;align-items:center;position:relative;max-width:100%!important;border-radius:4px;box-sizing:border-box;padding:2px}ngp-image-picker .place-image .image-holder-loaded .image-caption{position:absolute;right:0;bottom:-22px}ngp-image-picker .place-image .image-holder-loaded img{height:100%;max-height:100%;width:100%;max-width:100%;object-position:center;background:black}@media (max-width: 599px){ngp-image-picker .place-image .image-holder-loaded{max-height:195px!important}}ngp-image-picker .place-image .image-holder-loaded .image-upload-btn{transition:all .5s ease;position:relative;opacity:.85;width:50px;height:50px;color:#424242}ngp-image-picker .place-image .image-holder-loaded .image-upload-btn .material-icons{font-size:50px;width:50px;height:50px;line-height:50px;color:#424242}@media (max-width: 599px){ngp-image-picker .place-image .image-holder-loaded .image-upload-btn{opacity:1;width:30px;height:30px}ngp-image-picker .place-image .image-holder-loaded .image-upload-btn .material-icons{font-size:30px;width:30px;height:30px;line-height:30px}}ngp-image-picker .place-image .image-holder-loaded:hover .image-upload-btn{opacity:1;transition:all .5s ease}ngp-image-picker .place-image .editing-bar-btn{margin-top:2px}ngp-image-picker .place-image .editing-bar-btn .material-icons-button{height:20px;line-height:20px;width:24px}ngp-image-picker .place-image .editing-bar-btn .material-icons{line-height:20px!important;font-size:20px!important;width:20px!important;height:20px!important}ngp-image-picker .place-image .editing-bar-btn button{margin:4px;color:#424242;transition:all .5s ease}ngp-image-picker .place-image .editing-bar-btn button:hover{transition:all .25s ease-in}ngp-image-picker .place-image .editing-bar-btn a{margin:4px;color:#424242;transition:all .5s ease}ngp-image-picker .place-image .editing-bar-btn a:hover{transition:all .25s ease-in}@keyframes show{0%{top:-100vh;opacity:0}to{top:0;opacity:1}}ngp-image-picker .btn{padding:4px 8px;border-radius:4px;cursor:pointer}ngp-image-picker .btn .material-icons{color:#000000d1}ngp-image-picker .icon-btn{display:flex;justify-content:center;align-items:center;border:none;background-color:inherit;border-radius:50%;cursor:pointer}ngp-image-picker .icon-btn :active{transform:scale(.95)}ngp-image-picker .caption{font-size:11px;margin-top:2px!important;margin-bottom:0!important}ngp-image-picker button[disabled]{filter:brightness(.5);cursor:not-allowed}ngp-image-picker .croppr-container *{user-select:none;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box}ngp-image-picker .croppr-container img{vertical-align:middle;max-width:100%;max-height:650px;object-fit:cover;object-position:center}ngp-image-picker .croppr{position:relative;display:inline-block}ngp-image-picker .croppr-overlay{background:rgba(0,0,0,.5);position:absolute;inset:0;z-index:1;cursor:crosshair}ngp-image-picker .croppr-region{border:1px dashed rgba(0,0,0,.5);position:absolute;z-index:3;cursor:move;top:0;display:grid;gap:0px;grid-template-columns:repeat(3,1fr)}ngp-image-picker .croppr-imageClipped{position:absolute;inset:0;z-index:2;pointer-events:none}ngp-image-picker .croppr-handle{border:1px solid #ccc;background-color:#fafafa;width:14px;height:14px;position:absolute;z-index:4;top:0;border-radius:50%}\n"], dependencies: [{ kind: "directive", type: i1.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i1.NgStyle, selector: "[ngStyle]", inputs: ["ngStyle"] }, { kind: "component", type: EditImageComponent, selector: "lib-edit-image", inputs: ["labels", "imageSrc", "color", "initialState"], outputs: ["closeModal"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: NgpImagePickerComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ngp-image-picker', encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, template: "<div *ngIf=\"!loadImage\" class=\"place-image\">\n  <div\n    class=\"image-holder\"\n    [ngStyle]=\"{\n      width: this.config.width,\n      height: this.config.height,\n      borderRadius: this.config.borderRadius,\n      aspectRatio: this.config.aspectRatio\n    }\"\n  >\n    <button title=\"{{ labels['Upload a image'] }}\" class=\"icon-btn image-upload-btn\" (click)=\"onUpload($event)\">\n      <!--  <span class=\"material-icons\">add_a_photo</mat-icon> -->\n      <span class=\"material-icons\">add_a_photo</span>\n    </button>\n\n    <input #imagePicker type=\"file\" style=\"display: none\" [id]=\"'filePicker-' + this.uuidFilePicker\" (change)=\"handleFileSelect($event)\" />\n  </div>\n</div>\n<div *ngIf=\"loadImage\" class=\"place-image\">\n  <div\n    class=\"image-holder-loaded\"\n    [ngStyle]=\"{\n      width: this.config.width,\n      height: this.config.height,\n      borderRadius: this.config.borderRadius,\n      aspectRatio: this.config.aspectRatio\n    }\"\n  >\n    <img\n      [src]=\"this.imageSrc\"\n      alt=\"image-loaded\"\n      [ngStyle]=\"{ borderRadius: this.config.borderRadius, objectFit: this.config.objectFit }\"\n    />\n    <input #imagePicker type=\"file\" style=\"display: none\" [id]=\"'filePicker-' + this.uuidFilePicker\" (change)=\"handleFileSelect($event)\" />\n  </div>\n  <p\n    *ngIf=\"this.calculateSize()\"\n    class=\"caption image-caption\"\n    [ngStyle]=\"{\n      color: this.calculateSize() > 120 ? '#f44336' : 'unset',\n      fontWeight: this.calculateSize() > 120 ? '500' : 'unset'\n    }\"\n  >\n    size: {{ this.calculateSize() }}Kb &nbsp; {{ this.state.format }}\n  </p>\n\n  <div\n    style=\"flex-direction: row; box-sizing: border-box; display: flex; place-content: flex-start; align-items: flex-start\"\n    class=\"editing-bar-btn\"\n  >\n    <button\n      class=\"icon-btn\"\n      id=\"upload-img\"\n      *ngIf=\"!this.config.hideAddBtn\"\n      title=\"{{ labels['Upload a image'] }}\"\n      (click)=\"onUpload($event)\"\n    >\n      <span class=\"material-icons\">add_a_photo</span>\n    </button>\n    <button\n      class=\"icon-btn\"\n      id=\"edit-img\"\n      *ngIf=\"!this.config.hideEditBtn\"\n      title=\"{{ labels['Open the editor panel'] }}\"\n      (click)=\"onOpenEditPanel()\"\n    >\n      <span class=\"material-icons\">edit</span>\n    </button>\n    <a\n      id=\"download-img\"\n      *ngIf=\"!this.config.hideDownloadBtn\"\n      title=\"{{ labels['Download the image'] }}\"\n      [href]=\"this.imageSrc\"\n      download=\"{{ imageName }}\"\n    >\n      <span class=\"material-icons\">cloud_download</span>\n    </a>\n    <button class=\"icon-btn\" id=\"delete-img\" *ngIf=\"!this.config.hideDeleteBtn\" title=\"{{ labels['Remove'] }}\" (click)=\"onRemove()\">\n      <span class=\"material-icons\">delete</span>\n    </button>\n  </div>\n</div>\n\n<lib-edit-image\n  *ngIf=\"showEditPanel\"\n  [imageSrc]=\"this.imageSrc\"\n  [initialState]=\"this.state\"\n  [labels]=\"this.labels\"\n  [color]=\"this.color\"\n  (closeModal)=\"this.onCloseEditPanel($event)\"\n></lib-edit-image>\n", styles: ["ngp-image-picker p{margin:0!important;padding:0!important}ngp-image-picker .place-image{flex-direction:column;box-sizing:border-box;display:flex;place-content:flex-start;align-items:flex-start}ngp-image-picker .place-image .image-holder{flex-direction:column;display:flex;place-content:center;align-items:center;position:relative;border-radius:16px;max-width:100%!important;box-sizing:border-box;border:2px rgba(0,0,0,.3) solid;background-color:#fcfcfc}@media (max-width: 599px){ngp-image-picker .place-image .image-holder{max-width:100%!important;max-height:250px!important}}ngp-image-picker .place-image .image-holder .image-upload-btn{transition:all .5s ease;position:relative;opacity:.85;width:50px;height:50px;color:#424242}ngp-image-picker .place-image .image-holder .image-upload-btn .material-icons{font-size:50px;width:50px;height:50px;line-height:50px;color:#424242}@media (max-width: 599px){ngp-image-picker .place-image .image-holder .image-upload-btn{opacity:1;width:30px;height:30px}ngp-image-picker .place-image .image-holder .image-upload-btn .material-icons{font-size:30px;width:30px;height:30px;line-height:30px}}ngp-image-picker .place-image .image-holder:hover .image-upload-btn{opacity:1;transition:all .5s ease}ngp-image-picker .place-image .image-holder-loaded{flex-direction:column;display:flex;place-content:center;align-items:center;position:relative;max-width:100%!important;border-radius:4px;box-sizing:border-box;padding:2px}ngp-image-picker .place-image .image-holder-loaded .image-caption{position:absolute;right:0;bottom:-22px}ngp-image-picker .place-image .image-holder-loaded img{height:100%;max-height:100%;width:100%;max-width:100%;object-position:center;background:black}@media (max-width: 599px){ngp-image-picker .place-image .image-holder-loaded{max-height:195px!important}}ngp-image-picker .place-image .image-holder-loaded .image-upload-btn{transition:all .5s ease;position:relative;opacity:.85;width:50px;height:50px;color:#424242}ngp-image-picker .place-image .image-holder-loaded .image-upload-btn .material-icons{font-size:50px;width:50px;height:50px;line-height:50px;color:#424242}@media (max-width: 599px){ngp-image-picker .place-image .image-holder-loaded .image-upload-btn{opacity:1;width:30px;height:30px}ngp-image-picker .place-image .image-holder-loaded .image-upload-btn .material-icons{font-size:30px;width:30px;height:30px;line-height:30px}}ngp-image-picker .place-image .image-holder-loaded:hover .image-upload-btn{opacity:1;transition:all .5s ease}ngp-image-picker .place-image .editing-bar-btn{margin-top:2px}ngp-image-picker .place-image .editing-bar-btn .material-icons-button{height:20px;line-height:20px;width:24px}ngp-image-picker .place-image .editing-bar-btn .material-icons{line-height:20px!important;font-size:20px!important;width:20px!important;height:20px!important}ngp-image-picker .place-image .editing-bar-btn button{margin:4px;color:#424242;transition:all .5s ease}ngp-image-picker .place-image .editing-bar-btn button:hover{transition:all .25s ease-in}ngp-image-picker .place-image .editing-bar-btn a{margin:4px;color:#424242;transition:all .5s ease}ngp-image-picker .place-image .editing-bar-btn a:hover{transition:all .25s ease-in}@keyframes show{0%{top:-100vh;opacity:0}to{top:0;opacity:1}}ngp-image-picker .btn{padding:4px 8px;border-radius:4px;cursor:pointer}ngp-image-picker .btn .material-icons{color:#000000d1}ngp-image-picker .icon-btn{display:flex;justify-content:center;align-items:center;border:none;background-color:inherit;border-radius:50%;cursor:pointer}ngp-image-picker .icon-btn :active{transform:scale(.95)}ngp-image-picker .caption{font-size:11px;margin-top:2px!important;margin-bottom:0!important}ngp-image-picker button[disabled]{filter:brightness(.5);cursor:not-allowed}ngp-image-picker .croppr-container *{user-select:none;-moz-user-select:none;-webkit-user-select:none;-ms-user-select:none;box-sizing:border-box;-webkit-box-sizing:border-box;-moz-box-sizing:border-box}ngp-image-picker .croppr-container img{vertical-align:middle;max-width:100%;max-height:650px;object-fit:cover;object-position:center}ngp-image-picker .croppr{position:relative;display:inline-block}ngp-image-picker .croppr-overlay{background:rgba(0,0,0,.5);position:absolute;inset:0;z-index:1;cursor:crosshair}ngp-image-picker .croppr-region{border:1px dashed rgba(0,0,0,.5);position:absolute;z-index:3;cursor:move;top:0;display:grid;gap:0px;grid-template-columns:repeat(3,1fr)}ngp-image-picker .croppr-imageClipped{position:absolute;inset:0;z-index:2;pointer-events:none}ngp-image-picker .croppr-handle{border:1px solid #ccc;background-color:#fafafa;width:14px;height:14px;position:absolute;z-index:4;top:0;border-radius:50%}\n"] }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }]; }, propDecorators: { color: [{
                type: Input
            }], _imageSrc: [{
                type: Input
            }], _config: [{
                type: Input
            }], imagePicker: [{
                type: ViewChild,
                args: ['imagePicker', { static: false }]
            }], $imageChanged: [{
                type: Output
            }], $imageOriginal: [{
                type: Output
            }] } });

class NgpImagePickerModule {
}
NgpImagePickerModule.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: NgpImagePickerModule, deps: [], target: i0.ɵɵFactoryTarget.NgModule });
NgpImagePickerModule.ɵmod = i0.ɵɵngDeclareNgModule({ minVersion: "14.0.0", version: "15.0.4", ngImport: i0, type: NgpImagePickerModule, declarations: [NgpImagePickerComponent, TabsComponent, EditImageComponent, BasicFiltersComponent, CropperWrapperComponent], imports: [CommonModule, FormsModule, ReactiveFormsModule], exports: [NgpImagePickerComponent] });
NgpImagePickerModule.ɵinj = i0.ɵɵngDeclareInjector({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: NgpImagePickerModule, imports: [CommonModule, FormsModule, ReactiveFormsModule] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.0.4", ngImport: i0, type: NgpImagePickerModule, decorators: [{
            type: NgModule,
            args: [{
                    declarations: [NgpImagePickerComponent, TabsComponent, EditImageComponent, BasicFiltersComponent, CropperWrapperComponent],
                    imports: [CommonModule, FormsModule, ReactiveFormsModule],
                    exports: [NgpImagePickerComponent],
                    providers: [],
                }]
        }] });

/*
 * Public API Surface of ngp-image-picker
 */

/**
 * Generated bundle index. Do not edit.
 */

export { NgpImagePickerComponent, NgpImagePickerModule };
//# sourceMappingURL=ngp-image-picker.mjs.map
//# sourceMappingURL=ngp-image-picker.mjs.map
