/**
 * Croppr.js
 * https://github.com/jamesssooi/Croppr.js
 *
 * A JavaScript image cropper that's lightweight, awesome, and has
 * zero dependencies.
 *
 * (C) 2017 James Ooi. Released under the MIT License.
 */
import CropprCore from "./core";
/**
 * This class is a wrapper for CropprCore that merely implements the main
 * interfaces for the Croppr instance. Look into CropprCore for all the
 * main logic.
 */
export default class Croppr extends CropprCore {
    /**
     * @constructor
     * Calls the CropprCore's constructor.
     */
    constructor(element, options, _deferred = false) {
        super(element, options, _deferred);
    }
    /**
     * Gets the value of the crop region.
     * @param {String} [mode] Which mode of calculation to use: 'real', 'ratio' or
     *      'raw'.
     */
    getValue(mode) {
        return super.getValue(mode);
    }
    /**
     * Changes the image src.
     * @param {String} src
     */
    setImage(src) {
        return super.setImage(src);
    }
    /**
     * Destroys the Croppr instance
     */
    destroy() {
        return super.destroy();
    }
    /**
     * Moves the crop region to a specified coordinate.
     * @param {Number} x
     * @param {Number} y
     */
    moveTo(x, y) {
        this.box.move(x, y);
        this.redraw();
        // Call the callback
        if (this.options.onCropEnd !== null) {
            this.options.onCropEnd(this.getValue());
        }
        return this;
    }
    /**
     * Resizes the crop region to a specified width and height.
     * @param {Number} width
     * @param {Number} height
     * @param {Array} origin The origin point to resize from.
     *      Defaults to [0.5, 0.5] (center).
     */
    resizeTo(width, height, origin = [0.5, 0.5]) {
        this.box.resize(width, height, origin);
        //////////////////////////////////////////////////////////////////
        const parentWidth = this.cropperEl.offsetWidth;
        const parentHeight = this.cropperEl.offsetHeight;
        this.box.constrainToBoundary(parentWidth, parentHeight, [0.5, 0.5]);
        ///////////////////////////////////////////////////////////////////
        this.redraw();
        // Call the callback
        if (this.options.onCropEnd !== null) {
            this.options.onCropEnd(this.getValue());
        }
        return this;
    }
    /**
     * Scale the crop region by a factor.
     * @param {Number} factor
     * @param {Array} origin The origin point to resize from.
     *      Defaults to [0.5, 0.5] (center).
     */
    scaleBy(factor, origin = [0.5, 0.5]) {
        this.box.scale(factor, origin);
        this.redraw();
        // Call the callback
        if (this.options.onCropEnd !== null) {
            this.options.onCropEnd(this.getValue());
        }
        return this;
    }
    /**
     * Resets the crop region to the initial settings.
     */
    reset(newOptions) {
        if (newOptions) {
            this.options = { ...this.options, newOptions };
        }
        this.box = this.initializeBox(this.options);
        // console.log('ðŸš€ ~ file: croppr.ts ~ line 110 ~ Croppr ~ reset ~ this.box', this.box);
        this.redraw();
        // Call the callback
        if (this.options.onCropEnd !== null) {
            this.options.onCropEnd(this.getValue());
        }
        return this;
    }
    enableVisibility(state) {
        let croppContainer = document.querySelector(".croppr-container");
        if (!croppContainer)
            throw new Error("THere is not any croppr");
        if (state) {
            croppContainer.style.display = "block";
        }
        else {
            croppContainer.style.display = "none";
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3JvcHByLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbmdwLWltYWdlLXBpY2tlci9zcmMvbGliL2Z1bmN0aW9ucy9jcm9wcHIvY3JvcHByLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztHQVFHO0FBRUgsT0FBTyxVQUFVLE1BQU0sUUFBUSxDQUFDO0FBRWhDOzs7O0dBSUc7QUFDSCxNQUFNLENBQUMsT0FBTyxPQUFPLE1BQU8sU0FBUSxVQUFVO0lBQzVDOzs7T0FHRztJQUNILFlBQVksT0FBWSxFQUFFLE9BQVksRUFBRSxTQUFTLEdBQUcsS0FBSztRQUN2RCxLQUFLLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxTQUFTLENBQUMsQ0FBQztJQUNyQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILFFBQVEsQ0FBQyxJQUFVO1FBQ2pCLE9BQU8sS0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM5QixDQUFDO0lBRUQ7OztPQUdHO0lBQ0gsUUFBUSxDQUFDLEdBQVE7UUFDZixPQUFPLEtBQUssQ0FBQyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVEOztPQUVHO0lBQ0gsT0FBTztRQUNMLE9BQU8sS0FBSyxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBQ3pCLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsTUFBTSxDQUFDLENBQU0sRUFBRSxDQUFNO1FBQ25CLElBQUksQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNwQixJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7UUFFZCxvQkFBb0I7UUFDcEIsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsS0FBSyxJQUFJLEVBQUU7WUFDbkMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7U0FDekM7UUFDRCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSCxRQUFRLENBQUMsS0FBVSxFQUFFLE1BQVcsRUFBRSxNQUFNLEdBQUcsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDO1FBQ25ELElBQUksQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLEtBQUssRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFFdkMsa0VBQWtFO1FBQ2xFLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDO1FBQy9DLE1BQU0sWUFBWSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsWUFBWSxDQUFDO1FBQ2pELElBQUksQ0FBQyxHQUFHLENBQUMsbUJBQW1CLENBQUMsV0FBVyxFQUFFLFlBQVksRUFBRSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQyxDQUFDO1FBQ3BFLG1FQUFtRTtRQUNuRSxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7UUFFZCxvQkFBb0I7UUFDcEIsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLFNBQVMsS0FBSyxJQUFJLEVBQUU7WUFDbkMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7U0FDekM7UUFDRCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRDs7Ozs7T0FLRztJQUNILE9BQU8sQ0FBQyxNQUFXLEVBQUUsTUFBTSxHQUFHLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQztRQUN0QyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7UUFDL0IsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBRWQsb0JBQW9CO1FBQ3BCLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEtBQUssSUFBSSxFQUFFO1lBQ25DLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1NBQ3pDO1FBQ0QsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQ7O09BRUc7SUFDSCxLQUFLLENBQUMsVUFBZ0I7UUFDcEIsSUFBSSxVQUFVLEVBQUU7WUFDZCxJQUFJLENBQUMsT0FBTyxHQUFHLEVBQUUsR0FBRyxJQUFJLENBQUMsT0FBTyxFQUFFLFVBQVUsRUFBRSxDQUFDO1NBQ2hEO1FBQ0QsSUFBSSxDQUFDLEdBQUcsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUM1Qyx3RkFBd0Y7UUFDeEYsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1FBRWQsb0JBQW9CO1FBQ3BCLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQyxTQUFTLEtBQUssSUFBSSxFQUFFO1lBQ25DLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1NBQ3pDO1FBQ0QsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRUQsZ0JBQWdCLENBQUMsS0FBYztRQUM3QixJQUFJLGNBQWMsR0FDaEIsUUFBUSxDQUFDLGFBQWEsQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1FBQzlDLElBQUksQ0FBQyxjQUFjO1lBQUUsTUFBTSxJQUFJLEtBQUssQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDO1FBQ2hFLElBQUksS0FBSyxFQUFFO1lBQ1QsY0FBYyxDQUFDLEtBQUssQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO1NBQ3hDO2FBQU07WUFDTCxjQUFjLENBQUMsS0FBSyxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUM7U0FDdkM7SUFDSCxDQUFDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENyb3Bwci5qc1xuICogaHR0cHM6Ly9naXRodWIuY29tL2phbWVzc3Nvb2kvQ3JvcHByLmpzXG4gKlxuICogQSBKYXZhU2NyaXB0IGltYWdlIGNyb3BwZXIgdGhhdCdzIGxpZ2h0d2VpZ2h0LCBhd2Vzb21lLCBhbmQgaGFzXG4gKiB6ZXJvIGRlcGVuZGVuY2llcy5cbiAqXG4gKiAoQykgMjAxNyBKYW1lcyBPb2kuIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgQ3JvcHByQ29yZSBmcm9tIFwiLi9jb3JlXCI7XG5cbi8qKlxuICogVGhpcyBjbGFzcyBpcyBhIHdyYXBwZXIgZm9yIENyb3BwckNvcmUgdGhhdCBtZXJlbHkgaW1wbGVtZW50cyB0aGUgbWFpblxuICogaW50ZXJmYWNlcyBmb3IgdGhlIENyb3BwciBpbnN0YW5jZS4gTG9vayBpbnRvIENyb3BwckNvcmUgZm9yIGFsbCB0aGVcbiAqIG1haW4gbG9naWMuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENyb3BwciBleHRlbmRzIENyb3BwckNvcmUge1xuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIENhbGxzIHRoZSBDcm9wcHJDb3JlJ3MgY29uc3RydWN0b3IuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbGVtZW50OiBhbnksIG9wdGlvbnM6IGFueSwgX2RlZmVycmVkID0gZmFsc2UpIHtcbiAgICBzdXBlcihlbGVtZW50LCBvcHRpb25zLCBfZGVmZXJyZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHZhbHVlIG9mIHRoZSBjcm9wIHJlZ2lvbi5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFttb2RlXSBXaGljaCBtb2RlIG9mIGNhbGN1bGF0aW9uIHRvIHVzZTogJ3JlYWwnLCAncmF0aW8nIG9yXG4gICAqICAgICAgJ3JhdycuXG4gICAqL1xuICBnZXRWYWx1ZShtb2RlPzogYW55KSB7XG4gICAgcmV0dXJuIHN1cGVyLmdldFZhbHVlKG1vZGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoYW5nZXMgdGhlIGltYWdlIHNyYy5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHNyY1xuICAgKi9cbiAgc2V0SW1hZ2Uoc3JjOiBhbnkpIHtcbiAgICByZXR1cm4gc3VwZXIuc2V0SW1hZ2Uoc3JjKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyB0aGUgQ3JvcHByIGluc3RhbmNlXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIHJldHVybiBzdXBlci5kZXN0cm95KCk7XG4gIH1cblxuICAvKipcbiAgICogTW92ZXMgdGhlIGNyb3AgcmVnaW9uIHRvIGEgc3BlY2lmaWVkIGNvb3JkaW5hdGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB4XG4gICAqIEBwYXJhbSB7TnVtYmVyfSB5XG4gICAqL1xuICBtb3ZlVG8oeDogYW55LCB5OiBhbnkpIHtcbiAgICB0aGlzLmJveC5tb3ZlKHgsIHkpO1xuICAgIHRoaXMucmVkcmF3KCk7XG5cbiAgICAvLyBDYWxsIHRoZSBjYWxsYmFja1xuICAgIGlmICh0aGlzLm9wdGlvbnMub25Dcm9wRW5kICE9PSBudWxsKSB7XG4gICAgICB0aGlzLm9wdGlvbnMub25Dcm9wRW5kKHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2l6ZXMgdGhlIGNyb3AgcmVnaW9uIHRvIGEgc3BlY2lmaWVkIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3aWR0aFxuICAgKiBAcGFyYW0ge051bWJlcn0gaGVpZ2h0XG4gICAqIEBwYXJhbSB7QXJyYXl9IG9yaWdpbiBUaGUgb3JpZ2luIHBvaW50IHRvIHJlc2l6ZSBmcm9tLlxuICAgKiAgICAgIERlZmF1bHRzIHRvIFswLjUsIDAuNV0gKGNlbnRlcikuXG4gICAqL1xuICByZXNpemVUbyh3aWR0aDogYW55LCBoZWlnaHQ6IGFueSwgb3JpZ2luID0gWzAuNSwgMC41XSkge1xuICAgIHRoaXMuYm94LnJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCBvcmlnaW4pO1xuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgY29uc3QgcGFyZW50V2lkdGggPSB0aGlzLmNyb3BwZXJFbC5vZmZzZXRXaWR0aDtcbiAgICBjb25zdCBwYXJlbnRIZWlnaHQgPSB0aGlzLmNyb3BwZXJFbC5vZmZzZXRIZWlnaHQ7XG4gICAgdGhpcy5ib3guY29uc3RyYWluVG9Cb3VuZGFyeShwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0LCBbMC41LCAwLjVdKTtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgdGhpcy5yZWRyYXcoKTtcblxuICAgIC8vIENhbGwgdGhlIGNhbGxiYWNrXG4gICAgaWYgKHRoaXMub3B0aW9ucy5vbkNyb3BFbmQgIT09IG51bGwpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5vbkNyb3BFbmQodGhpcy5nZXRWYWx1ZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogU2NhbGUgdGhlIGNyb3AgcmVnaW9uIGJ5IGEgZmFjdG9yLlxuICAgKiBAcGFyYW0ge051bWJlcn0gZmFjdG9yXG4gICAqIEBwYXJhbSB7QXJyYXl9IG9yaWdpbiBUaGUgb3JpZ2luIHBvaW50IHRvIHJlc2l6ZSBmcm9tLlxuICAgKiAgICAgIERlZmF1bHRzIHRvIFswLjUsIDAuNV0gKGNlbnRlcikuXG4gICAqL1xuICBzY2FsZUJ5KGZhY3RvcjogYW55LCBvcmlnaW4gPSBbMC41LCAwLjVdKSB7XG4gICAgdGhpcy5ib3guc2NhbGUoZmFjdG9yLCBvcmlnaW4pO1xuICAgIHRoaXMucmVkcmF3KCk7XG5cbiAgICAvLyBDYWxsIHRoZSBjYWxsYmFja1xuICAgIGlmICh0aGlzLm9wdGlvbnMub25Dcm9wRW5kICE9PSBudWxsKSB7XG4gICAgICB0aGlzLm9wdGlvbnMub25Dcm9wRW5kKHRoaXMuZ2V0VmFsdWUoKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgY3JvcCByZWdpb24gdG8gdGhlIGluaXRpYWwgc2V0dGluZ3MuXG4gICAqL1xuICByZXNldChuZXdPcHRpb25zPzogYW55KSB7XG4gICAgaWYgKG5ld09wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IHsgLi4udGhpcy5vcHRpb25zLCBuZXdPcHRpb25zIH07XG4gICAgfVxuICAgIHRoaXMuYm94ID0gdGhpcy5pbml0aWFsaXplQm94KHRoaXMub3B0aW9ucyk7XG4gICAgLy8gY29uc29sZS5sb2coJ/CfmoAgfiBmaWxlOiBjcm9wcHIudHMgfiBsaW5lIDExMCB+IENyb3BwciB+IHJlc2V0IH4gdGhpcy5ib3gnLCB0aGlzLmJveCk7XG4gICAgdGhpcy5yZWRyYXcoKTtcblxuICAgIC8vIENhbGwgdGhlIGNhbGxiYWNrXG4gICAgaWYgKHRoaXMub3B0aW9ucy5vbkNyb3BFbmQgIT09IG51bGwpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5vbkNyb3BFbmQodGhpcy5nZXRWYWx1ZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBlbmFibGVWaXNpYmlsaXR5KHN0YXRlOiBib29sZWFuKSB7XG4gICAgbGV0IGNyb3BwQ29udGFpbmVyOiBIVE1MRWxlbWVudCB8IGFueSA9XG4gICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmNyb3Bwci1jb250YWluZXJcIik7XG4gICAgaWYgKCFjcm9wcENvbnRhaW5lcikgdGhyb3cgbmV3IEVycm9yKFwiVEhlcmUgaXMgbm90IGFueSBjcm9wcHJcIik7XG4gICAgaWYgKHN0YXRlKSB7XG4gICAgICBjcm9wcENvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgIH0gZWxzZSB7XG4gICAgICBjcm9wcENvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgfVxuICB9XG59XG4iXX0=